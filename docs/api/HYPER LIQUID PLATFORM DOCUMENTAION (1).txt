
üöÄ HYPERLIQUID PLATFORM DOCUMENTATION
==================================================
UPDATED: 2025-07-06 | 100% PERFECTION ACHIEVED
==================================================

‚ö†Ô∏è IMPORTANT: For comprehensive developer documentation with 100% perfection best practices,
   error handling, and complete API guides, see: HYPERLIQUID_COMPREHENSIVE_DOCUMENTATION.md

This file contains the original Hyperliquid documentation.
For building 100% perfect trading bots, refer to the comprehensive documentation above.

==================================================

Hyperliquid Docs

Search...
Ctrl
K
About Hyperliquid
Core contributors
Onboarding
HyperCore
HyperEVM
Hyperliquid Improvement Proposals (HIPs)
Trading
Validators
Referrals
Points
Historical data
Risks
Bug bounty program
Audits
Brand kit
For developers
API
HyperEVM
Nodes
Powered by GitBook
What is Hyperliquid?
Technical overview
About Hyperliquid
What is Hyperliquid?
Hyperliquid is a performant blockchain built with the vision of a fully onchain open financial system. Liquidity, user applications, and trading activity synergize on a unified platform that will ultimately house all of finance. 

Technical overview
Hyperliquid is a layer one blockchain (L1) written and optimized from first principles. 

Hyperliquid uses a custom consensus algorithm called HyperBFT inspired by Hotstuff and its successors. Both the algorithm and networking stack are optimized from the ground up to support the unique demands of the L1. 

Hyperliquid state execution is split into two broad components: HyperCore and the HyperEVM. HyperCore includes fully onchain perpetual futures and spot order books. Every order, cancel, trade, and liquidation happens transparently with one-block finality inherited from HyperBFT. HyperCore currently supports 200k orders / second, with throughput constantly improving as the node software is further optimized.

The HyperEVM brings the familiar general-purpose smart contract platform pioneered by Ethereum to the Hyperliquid blockchain. With the HyperEVM, the performant liquidity and financial primitives of HyperCore are available as permissionless building blocks for all users and builders. See the HyperEVM documentation section for more technical details.


Next
Core contributors
Last updated 3 months ago

Core contributors
Hyperliquid Labs is a core contributor supporting the growth of Hyperliquid, led by Jeff and iliensinc, who are classmates from Harvard. Other members of the team are from Caltech and MIT and previously worked at Airtable, Citadel, Hudson River Trading, and Nuro. 

The team used to do proprietary market making in crypto in 2020 and expanded into defi in the summer of 2022. Existing platforms were plagued with issues, such as poor market design, bad tech, and clunky UX. It was easy to make money trading on these protocols, but disappointing to see how far behind defi was compared to its centralized counterparts. The team set out to build a product that could solve these issues and provide users with a seamless trading experience. 

Designing a performant decentralized L1 with an order book DEX built-in requires an intimate understanding of quantitative trading, cutting-edge blockchain technology, and clean UX, which the team is well-positioned to deliver. The team actively engages with and listens to the community; you are welcome to join the Discord server to ask questions and share feedback.

Lastly, Hyperliquid Labs is self-funded and has not taken any external capital, which allows the team to focus on building a product they believe in without external pressure.

Onboarding
How to use the HyperEVM
For users:
How do I add the HyperEVM to my wallet extension?
You can add the HyperEVM to your wallet extension by using Chainlist (https://chainlist.org/chain/999) or following these steps:  

In your wallet extension, click ‚ÄúAdd Custom Network‚Äù and enter the information below:  

Chain ID: 999 

Network Name: Hyperliquid 

RPC URL: https://rpc.hyperliquid.xyz/evm 

Block explorer URL (optional): 

https://purrsec.com/ 

https://hyperliquid.cloud.blockscout.com/ 

(other explorers coming soon ‚Äî many thanks to the community members building these)

Currency Symbol: HYPE


How do I move assets to and from the HyperEVM?
You can send assets to the HyperEVM from your Spot balances on HyperCore and vice versa by clicking the ‚ÄúTransfer to/from EVM‚Äù button on the Balances table of the Trade or Portfolio pages or clicking the "EVM <-> Core Transfer" button at the top of the Portfolio page.  

You can also send your HYPE to 0x2222222222222222222222222222222222222222 from either your Spot balances or from the EVM to transfer. Note that this only works for HYPE; sending other assets will lead to them being lost. Each spot asset has a unique transfer address. 

Sending from the HyperEVM to your Spot balances costs gas in HYPE on the HyperEVM. Sending from your Spot balances to the HyperEVM cost gas in HYPE on HyperCore (Spot).  


What can I do on the HyperEVM?
Various teams are building applications, tooling, etc. on the HyperEVM. There are many community initiatives to track new releases on the HyperEVM, including:

https://www.hypurr.co/ecosystem-projects, https://hyperliquid.wiki/, https://data.asxn.xyz/dashboard/hyperliquid-ecosystem, and the #hyperevm-eco channel in https://discord.gg/hyperliquid 

How does the HyperEVM interact with the rest of the Hyperliquid blockchain? 
Hyperliquid is one state with HyperCore state (e.g., perps, spot, order books, other trading features) and HyperEVM state. Because everything is secured by the same HyperBFT consensus, there will ultimately be seamless integration between the two. You can build an application on the HyperEVM involving lending, trading, yield generation, etc. That application can directly access the liquidity on the order books, so that defi has CEX-like functionality for the first time. The application token can also list on native Hyperliquid trading permissionlessly, so that trading happens on the same chain as building.

Why does gas spike?
While the Hyperliquid native blockchain is one of the most performant, high throughput blockchains today, the HyperEVM was intentionally launched with lower initial throughput. Because HyperCore and the HyperEVM share the same state, it is technically risky to allow the HyperEVM to consume more bandwidth on initial launch. The HyperEVM throughput will be increased over time in a gradual technical rollout.

Gas spikes on any chain when there is more demand than supply of blockspace. The HyperEVM uses the same gas system as Ethereum and many L2s, where there is a base fee and a priority fee: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md

Can I send HYPE on the HyperEVM to a centralized exchange?
First confirm with the CEX that they support the HyperEVM. Note that the HyperEVM is one part of the Hyperliquid blockchain. HyperCore (e.g., perps, spot, and other trading features) and the HyperEVM are separate parts of the same blockchain. Some CEXs support sending and receiving HYPE from Spot balances on HyperCore, but not the HyperEVM. Always remember to do a test transaction when you are trying something for the first time. 

How do I bridge assets to the HyperEVM from another chain? 
There are many different bridges / swaps, including: 

LayerZero: https://www.hyperbridge.xyz/

DeBridge: https://app.debridge.finance/

Gas.zip: https://www.gas.zip/

Cortex for HYPE: https://cortexprotocol.com/agent?q=buy%20hype

Garden for BTC: https://app.garden.finance/ 

Mintify for ETH: https://mintify.xyz/crypto

USDT0 for USDT0: https://usdt0.to/transfer

Stargate for USDe: https://stargate.finance/bridge?srcChain=ethereum&srcToken=0x4c9EDD5852cd905f086C759E8383e09bff1E68B3&dstChain=hyperliquid&dstToken=0x5d3a1Ff2b6BAb83b63cd9AD0787074081a52ef34

For builders: 
What can I build on the HyperEVM?
Any application from other chains can already be built with the limited launch. The HyperEVM is a fully functional EVM of its own. Other features live on testnet will gradually roll out to mainnet.

How do I set up an RPC? What RPCs are available?
There is one rpc hosted at rpc.hyperliquid.xyz/evm

Other builders are launching their own as well. Users may run a node, but it is not a requirement to serve an RPC, as all data is uploaded real-time to S3. See python SDK for an example: https://github.com/hyperliquid-dex/hyperliquid-python-sdk/blob/master/examples/evm_block_indexer.py

How do I get gas on the HyperEVM?
The native token, HYPE, is the gas token on the HyperEVM. You can buy HYPE with USDC on Hyperliquid and then transfer from HyperCore to the HyperEVM. You can also use the bridges mentioned in How do I bridge assets to the HyperEVM from another chain? 

What version of the EVM is the HyperEVM based on?
Cancun without blobs

What is the difference between the HyperEVM and other EVMs, like Ethereum?
Functionality is largely the same, which makes it easy to build similar tooling and applications. The main differences are:

Dual block system: fast small blocks and slow big blocks

Interactions with the native side of the Hyperliquid state, providing a seamless onboarding for all Hyperliquid users to the HyperEVM

HyperCore
Overview
Consensus
Hyperliquid is secured by HyperBFT, a variant of HotStuff consensus. Like most proof of stake chains, blocks are produced by validators in proportion to the native token staked to each validator. 

Execution
The Hyperliquid state is comprised of HyperCore and the general purpose HyperEVM. 

HyperCore include margin and matching engine state. Importantly, HyperCore does not rely on the crutch of off-chain order books. A core design principle is full decentralization with one consistent order of transactions achieved through HyperBFT consensus. 

Latency
Consensus currently uses an optimized consensus algorithm called HyperBFT, which is optimized for end-to-end latency. End-to-end latency is measured as duration between sending request to receiving committed response. 

For an order placed from a geographically co-located client, end-to-end latency has a median 0.2 seconds and 99th percentile 0.9 seconds. This performance allows users to port over automated strategies from other crypto venues with minimal changes and gives retail users instant feedback through the UI.

Throughput
Mainnet currently supports approximately 200k orders/sec. The current bottleneck is execution. The consensus algorithm and networking stack can scale to millions of orders per second once the execution can keep up. There are plans to further optimize the execution logic once the need arises.

Bridge
Deposits to the bridge are signed by the validators and are credited when more than 2/3 of the staking power has signed the deposit.

Withdrawals from Hyperliquid are immediately deducted from the L1 balance, and validators sign the withdrawal as separate transactions. When 2/3 of the staking power has signed the withdrawal, an EVM transaction can be sent to the bridge to request the withdrawal. 

After a withdrawal is requested, there is a dispute period during which the bridge can be locked for a malicious withdrawal that does not match the Hyperliquid state. Cold wallet signatures of 2/3 of the stake-weighted validator set are required to unlock the bridge.  

After the dispute period, finalization transactions are sent, which distribute the USDC to the corresponding destination addresses. There is a similar mechanism to maintain the set of active validators and their corresponding stake on the bridge contract. 

Withdrawals do not require any Arbitrum ETH from the user. Instead, a withdrawal gas fee of 1 USDC is paid by the user on Hyperliquid to cover the Arbitrum gas costs of the validators.  

The bridge and its logic in relation to the L1 staking have been audited by Zellic. See the Hyperliquid Github repository for the full bridge code, and the Audits section for the audit reports.

HyperCore
API servers
API servers listen to updates from a node and maintains the blockchain state locally. The API server serves information about this state and also forwards user transactions to the node. The API serves two sources of data, REST and Websocket. 

When user transactions are sent to an API server, they are forwarded to the connected node, which then gossips the transaction as part of the HyperBFT consensus algorithm. Once the transaction has been included in a committed block on the L1, the API server responds to the original request with the execution response from the L1.


HyperCore
Clearinghouse
The perps clearinghouse is a component of the execution state on HyperCore. It manages the perps margin state for each address, which includes balance and positions. 

Deposits are first credited to an address's cross margin balance. Positions by default are also opened in cross margin mode. Isolated margin is also supported, which allows users to allocate margin towards a specific position, disassociating the liquidation risk of that position with all other positions.

The spot clearinghouse analogously manages spot user state for each address, including token 




HyperCore
Oracle
The validators are responsible for publishing spot oracle prices for each perp asset every 3 seconds. The oracle prices are used to compute funding rates. They are also a component in the mark price which is used for margining, liquidations, and triggering TP/SL orders.

The spot oracle prices are computed by each validator as the weighted median of Binance, OKX, Bybit, Kraken, Kucoin, Gate IO, MEXC, and Hyperliquid spot prices for each asset, with weights 3, 2, 2, 1, 1, 1, 1, 1 respectively. Perps on assets which have primary spot liquidity on Hyperliquid (e.g. HYPE) do not include external sources in the oracle until sufficient liquidity is met. Perps on assets that have primary spot liquidity outside of Hyperliquid (e.g. BTC) do not include Hyperliquid spot prices in the oracle.

The final oracle price used by the clearinghouse is the weighted median of each validator's submitted oracle prices, where the validators are weighted by their stake.



HyperCore
Order book
HyperCore state includes an order book for each asset. The order book works in similarly to centralized exchanges. Orders are added where price is an integer multiple of the tick size, and size is an integer multiple of lot size. Orders are matched in price-time priority. 

Operations on order books for perp assets take a reference to the clearinghouse, as all positions and margin checks are handled there. Margin checks happen on the opening of a new order, and again for the resting side at the matching of each order. This ensures that the margining system is consistent despite oracle price fluctuations after the resting order is placed.

HyperCore
Staking
Basics
HYPE staking on Hyperliquid happens within HyperCore. Just as USDC can be transferred between perps and spot accounts, HYPE can be transferred between spot and staking accounts. 

Within the staking account, HYPE may be staked to any number of validators. Here and in other docs, delegate and stake are used interchangeably, as Hyperliquid only supports delegated proof of stake. 

Each validator has a self-delegation requirement of 10000 HYPE to become active. Once active, validators produce blocks and receive rewards proportional to their total delegated stake. Validators may charge a commission to their delegators. This commission cannot be increased unless the new commission is less than or equal to 1%. This prevents scenarios where a validator attracts a large amount of stake and then raises the commission significantly to take advantage of unaware stakers.

Delegations to a particular validator have a lockup duration of 1 day. After this lockup, delegations may be partially or fully undelegated at any time. Undelegated balances instantly reflect in staking account balance. 

Transfers from spot account to staking account are instant. However, transfers from staking account to spot account have a 7 day unstaking queue. Most other proof of stake chains have a similar mechanism, which ensures that large-scale consensus attacks are penalized by slashing or social layer mechanisms. There is currently no automatic slashing implemented. 

As an example, if you initiate a staking to spot transfer of 100 HYPE at 08:00:00 UTC on March 11 and a transfer of 50 HYPE at 09:00:00 UTC on March 12, the 100 HYPE transfer will be finalized at 08:00:01 UTC on March 18 and the 50 HYPE transfer will be finalized at 09:00:01 UTC on March 19. 

The staking reward rate formula is inspired by Ethereum, where the reward rate is inversely proportional to the square root of total HYPE staked. At 400M total HYPE staked, the yearly reward rate is approximately 2.37% per year. Staking rewards come from the future emissions reserve.

Rewards are accrued every minute and distributed to stakers every day. Rewards are redelegated automatically to the staked validator, i.e. compounded.

Technical Details
The notion of a quorum is essential to modern proof of stake consensus algorithms such as HyperBFT. A quorum is any set of validators that has more than ‚Öî of the total stake in the network. The operating requirement of consensus is that a quorum of stake is honest (non-Byzantine). Therefore it is an essential responsibility of every staker to only delegate to trusted validators. 

HyperBFT consensus proceeds in rounds, which is a fundamental discrete bundle of transactions along with signatures from a quorum of validators. Each round may be committed after certain conditions are met, after which it is sent to the execution state for processing. A key property of the consensus algorithm is that all honest nodes agree on the ordered list of committed rounds.

Rounds may result in a new execution state block. Execution blocks are indexed by a separate increasing counter called height. Height only increments on consensus rounds with at least one transaction.

The validator set evolves in epochs of 100000 rounds, which is approximately 90 minutes on mainnet. The validators and consensus stakes are static for each staking epoch.

Validators may vote to jail peers that do not respond with adequate latency or frequency to the consensus messages of the voter. Upon receiving a quorum of jail votes, a validator becomes jailed and no longer participates in consensus. A jailed validator does not produce rewards for its delegators. A validator may unjail themselves by diagnosing and fixing the causes, subject to onchain unjailing rate limits. Note that jailing is not the same slashing, which is reserved for provably malicious behavior such as double-signing blocks at the same round. 


HyperCore
Vaults
Vaults are a powerful and flexible primitive built into HyperCore. Strategies running on vaults benefit from the same advanced features as the DEX, from liquidations of overleveraged accounts to high throughput market making strategies. No more depositing into vaults that simply rebalance two tokens. 

Anyone can deposit into a vault to earn a share of the profits. In exchange, the vault owner receives 10% of the total profits. (Note that protocol vaults do not have any fees or profit share). Vaults can be managed by an individual trader or automated by a market maker. All strategies come with their own risk, and users should carefully assess the risks and performance history of a vault before depositing.  

Protocol vaults
Hyperliquidity Provider (HLP) is a protocol vault that does market making and liquidations and receives a portion of trading fees. 

HLP democratizes strategies typically reserved for privileged parties on other exchanges. The community can provide liquidity for the vault and share its pnl. HLP is fully community-owned.

The deposit lock-up period is 4 days. This means you can withdraw 4 days after your most recent deposit. E.g., if you deposited on Sep 14 at 08:00, you would be able to withdraw on Sep 18 at 08:00.

For more information about HLP, see these blog posts: 

https://medium.com/@hyperliquid/hyperliquidity-provider-hlp-democratizing-market-making-bb114b1dff0f
https://medium.com/@hyperliquid/hlp-update-3-months-in-42327abe3e57
Note that the blog posts may not be up-to-date.

HyperCore
Vaults
For vault leaders
What are the benefits of creating a vault as a leader?
Vault leaders receive a 10% profit share for managing the vault. Vaults can be a great way for a trader to share strategies with his or her community. 

How do I create a vault?
Anyone can create a vault: 

Choose a name and write a description for your vault. Note that this cannot be changed later. 

Deposit a minimum of 100 USDC into your vault.

Creating a vault requires a 100 USDC gas fee, which is distributed to the protocol in the same manner as trading fees.

To ensure vault leaders have skin in the game, you must maintain ‚â•5% of the vault at all times. You cannot withdraw from your vault if it would cause your share to fall below 5%. 

How do I manage my vault?
On the Trade page, select the address dropdown in the navigation bar. Select the vault you want to trade on behalf of in the dropdown. Now, all trades you make will apply to your vault, and everything on the Trade page will reflect your vault. 

To switch back to your personal account, select "Master" at the top of the address dropdown.   

How do I close my vault?
On your vault‚Äôs dedicated page, click the Leader Actions dropdown and select ‚ÄúClose Vault‚Äù. A modal will appear to confirm that you want to close your vault. All positions must be closed before the vault can close. All depositors will receive their share of the vault when it is closed.

What happens to open positions in a vault when someone withdraws?
When someone withdraws from a vault, if there is enough initial margin to keep the open positions according to the leverages set, the withdrawal does not affect open positions.

If there is not enough initial margin for the open positions, a proportional amount of the withdrawal is closed for all open positions. For example, if a user comprised 10% of the vault‚Äôs total deposits, 10% of all open positions would be closed when they withdraw. This way, the liquidation price of any open orders stays in a similar range. 

Vault leaders can also set vaults to always proportionally close positions on withdrawals to maintain similar liquidation prices for positions.

Open orders that are using margin will be canceled when there is insufficient margin for a withdrawal. Orders will be canceled in increasing order of margin used.  

For vault depositors
What are the benefits of depositing into a vault?
By depositing, you earn a share of the profits, or losses, of the vault. If there are specific traders you admire or support, you can deposit into their vault to get exposure to their trading strategies. 

Let‚Äôs say you deposit 100 USDC into a vault, whose total deposits are 900 USDC. The vault total is now 1,000 USDC, and you represent 10% of the vault. Over time, the vault grows to be 2,000 USDC, while no one else has deposited or withdrawn from the vault. You withdraw 200 USDC (10%) less 10 USDC (10% profit share to the leader), which totals 190 USDC. There may be some slippage as you withdraw and open positions are closed. 

Note that trading is inherently risky, and vaults‚Äô past performance is not a guarantee of future returns. 

How do I find a vault to deposit into?
On https://app.hyperliquid.xyz/vaults, you can view statistics of different vaults, including APY and total deposits (TVL). 

You can click on a specific vault to see more information, such as pnl, max drawdown, volume, open positions, and trade history. You can see how many people have deposited into the vault and for how long they‚Äôve been supporting the vault. 

How do I deposit into a vault?
Depositing into a vault is simple. On a vault‚Äôs dedicated page, enter the amount you would like to deposit and click ‚ÄúDeposit.‚Äù

How do I check the performance of vaults I‚Äôve deposited into?
You can track any vault‚Äôs performance on its dedicated page. Select the ‚ÄúYour Performance‚Äù heading to see how your deposits have performed. 

On the Portfolio page, you‚Äôll find your total balance across all vaults. 

How do I withdraw from a vault?
Withdrawing is as simple as depositing. On a vault‚Äôs dedicated page, click the Withdraw heading, then enter the amount you‚Äôd like to withdraw and click ‚ÄúWithdraw.‚Äù

HLP has a lock-up period of 4 days. User vaults have a lock-up period of 1 day. 



HyperCore
Multi-sig
Advanced Feature

HyperCore supports native multi-sig actions. This allows multiple private keys to control a single account for additional security. Unlike other chains, multi-sig is available as a built-in primitive on HyperCore as opposed to relying on smart contracts. 

The multi-sig workflow is described below:

To convert a user to a multi-sig user, the user sends a ConvertToMultiSigUser action with the authorized users and the minimum required number of authorized users required to sign an action. Authorized users must be existing users on Hyperliquid. Once a user has been converted into a multi-sig user, all its actions must be sent via multi-sig. 

To send an action, each authorized user must sign a payload to produce a signature. A MultiSig action wraps around any normal action and includes a list of signatures from authorized users. 

The MutiSig payload also contains the target multi-sig user and the authorized user who will ultimately send the MultiSig action to the blockchain. The sender of the final action is also known as the leader (transaction lead address) of the multi-sig action.

When a multi-sig action is sent, only the nonce set of the authorized user who sent the transaction is validated and updated.

Similarly to normal actions, the leader can also be an API wallet of an authorized user. In this case, the nonce of the API wallet is checked and updated. 

A multi-sig user's set of authorized users and/or the threshold may be updated by sending a MultiSig action wrapping aConvertToMultiSigUser action describing the new state.

A multi-sig user can be converted back to a normal user by sending a ConvertToMultiSigUser via multi-sig. In this case, the set of authorized users can be set to empty and conversion to normal user will be performed.

Miscellaneous notes: 

The leader (transaction lead address) must be an authorized user, not the multi-sig account

Each signature must use the same information, e.g., same nonce, transaction lead address, etc. 

The leader must collect all signatures before submitting the action 

A user can be a multi-sig user and an authorized user for another multi-sig user at the same time. A user may be an authorized user for multiple multi-sig users. The maximum allowed number of authorized users for a given multi-sig user is 10. 

Important for HyperEVM users: Converting a user to a multi-sig still leaves the HyperEVM user controllable by the original wallet. In general, multi-sig users should not interact with the HyperEVM before or after conversion.

See the Python SDK for code examples.

HyperEVM
The Hyperliquid blockchain features two key parts: HyperCore and HyperEVM. The HyperEVM is not a separate chain, but rather, secured by the same HyperBFT consensus as HyperCore. This lets the HyperEVM interact directly with parts of HyperCore, such as spot and perp order books.

What can I do on the HyperEVM? 
Explore directories of apps, tools, and more built by community members: HypurrCo, ASXN, and Hyperliquid.wiki. Visit the HyperEVM onboarding FAQ for more questions. 

Why build on the HyperEVM?
Builders can plug into a mature, liquid, and performant onchain order books with HyperCore + HyperEVM on Hyperliquid. In addition, Hyperliquid has a captive audience of users who want to be at the forefront of financial change; they are excited to try new applications and conduct finance onchain. See the HyperEVM developer section for more technical details and tools for HyperEVM builders for resources.  

As one example, a project XYZ could deploy an ERC20 contract on the HyperEVM using standard EVM tooling and deploy a corresponding spot asset XYZ permissionlessly in the HyperCore spot auction. Once the HyperCore token and HyperEVM contract are linked, users can use the same XYZ token on HyperEVM applications and trade it with on the native spot order book. This has two key improvements compared to CEX listings: 1) The entire process is permissionless, with no behind-the-scenes negotiations for preferential treatment and 2) There is no bridging risk between HyperCore and HyperEVM as one unified state. Trading and building on the same chain is a 10x product improvement over CEXs.

As another example, a lending protocol could set up a pool contract that accepts token XYZ as collateral and lends out another token ABC to the borrower. To determine the liquidation threshold, the lending smart contract can read XYZ/ABC prices directly from the HyperCore order books using a read precompile. For a Solidity developer, this is as simple as calling a built-in function. Suppose the borrower's position requires liquidation. The lending smart contract can send orders directly swapping XYZ and ABC on the HyperCore order books using a write system contract. Again, this is a simple built-in function in Solidity. In a few lines of code, the lending protocol has implemented protocolized liquidations similar to how perps function on HyperCore. A theme of the HyperEVM is to abstract away the deep liquidity on HyperCore as a building block for arbitrary user applications.

What stage is the HyperEVM in? 
The HyperEVM is in the alpha stage. There are three reasons behind this gradual roll-out approach. 

First, this stays true to Hyperliquid‚Äôs ‚Äúno insiders‚Äù principle; everyone has equal access and starts on a level playing field. The tradeoff is that HyperEVM did not launch with the same tooling you might see on other chains, since no one is given a heads up nor paid for an integration or marketing. These short term obstacles are worth it to be a fair, credibly neutral platform in the long-run. 

Second, a gradual roll-out is the safest way to upgrade a complex system doing billions of dollars of volume a day and protect against performance degradation or downtime. 

Third, shipping an MVP and iterating live with user feedback allows development to adjust more nimbly. Testnets are useful for technical testing, but systems can only be hardened through real economic use. 

As such, higher throughput and write system contracts are not live on mainnet yet, but will be in due time. 


HyperEVM
Tools for HyperEVM builders
EVM RPCs

Mainnet: https://rpc.hyperliquid.xyz/evm

Testnet: https://rpc.hyperliquid-testnet.xyz/evm 

HypurrScan: http://rpc.hypurrscan.io 

Stakely: https://hyperliquid-json-rpc.stakely.io

Quicknode: https://www.quicknode.com/chains/hyperliquid

Chainstack: https://chainstack.com/build-better-with-hyperliquid/

EVM RPCs with archive node support

HypeRPC by Imperator: https://hyperpc.app/ 

Proof Group: https://www.purroofgroup.com/ 

Altitude - https://rpc.reachaltitude.xyz/

Native gas 

Courtesy the HyperEVM onboarding FAQ 

Gas.zip: https://www.gas.zip/

DeBridge: https://app.debridge.finance/

Cortex: https://cortexprotocol.com/agent?q=buy%20hype

Big block/small block toggle

https://hyperevm-block-toggle.vercel.app

Python SDK example 

https://github.com/hyperliquid-dex/hyperliquid-python-sdk/blob/master/examples/basic_evm_use_big_blocks.py 

Oracles 

Pyth: https://docs.pyth.network/price-feeds/contract-addresses/evm 

Stork: https://docs.stork.network/resources/contract-addresses/evm#hyperevm 

Redstone: https://app.redstone.finance/app/feeds/?page=1&sortBy=popularity&sortDesc=false&perPage=32&networks=999,998 

Blocksense: https://coda.io/@georgi-zlatarev/blocksense-hyperevm-price-feeds

Crosschain messaging 

LayerZero: https://docs.layerzero.network/v2/deployments/deployed-contracts?chains=hyperliquid 

DeBridge: https://docs.debridge.finance/the-debridge-messaging-protocol/deployed-contracts#evm-chains 

Hyperlane: https://docs.hyperlane.xyz/docs/reference/default-ism-validators

Indexing / subgraphs 

Goldsky: https://docs.goldsky.com/chains/hyperevm 

Allium: https://docs.allium.so/historical-chains/supported-blockchains/hyperliquid 

SQD: https://docs.sqd.ai/hyperliquid-support/

SAFE multi-sig instances

Den: https://safe.onchainden.com/welcome

Palmera: https://x.com/palmera_dao/status/1899460307401019488

MPC multi-sig

Fireblocks: https://www.fireblocks.com/integrations/protocols/

Tholos: https://www.tholos.app/ 

Smart contract tooling

Gelato: https://docs.gelato.network/web3-services

Account abstraction

ZeroDev: https://docs.zerodev.app/


Trading
Perpetual assets
Hyperliquid currently supports trading of 100+ assets. Assets are added according to community input. Ultimately Hyperliquid will feature a decentralized and permissionless listing process. 

Max leverage varies by asset, ranging from 3x to 40x. Maintenance margin is half of the initial margin at max leverage. E.g., if max leverage is 20x, the maintenance margin is 2.5%.



Trading
Contract specifications
Hyperliquid perpetuals are derivatives products without expiration date. Instead, they rely on funding payments to ensure convergence to the underlying spot price over time. See Funding for more information. 

Hyperliquid has one main style of margining for perpetual contracts: USDC margining, USDT denominated linear contracts. That is, the oracle price is denominated in USDT, but the collateral is USDC. This allows for the best combination of liquidity and accessibility. Note that no conversions with the USDC/USDT exchange rate are applied, so these contracts are technically quanto contracts where USDT pnl is denominated in USDC.

When the spot asset's primary source of liquidity is USDC denominated, the oracle price is denominated in USDC. Currently, the only USDC-denominated perpetual contracts are PURR-USD and HYPE-USD, where the most liquid spot oracle source is Hyperliquid spot.

Hyperliquid's contract specifications are simpler than most platforms. There are few contract-specific details and no address-specific restrictions.

Instrument type

Linear perpetual

Contract

1 unit of underlying spot asset

Underlying asset / ticker

Hyperliquid oracle index of underlying spot asset

Initial margin fraction

1 / (leverage set by user) 

Maintenance margin fraction

Half of maximum initial margin fraction

Mark price

See here

Delivery / expiration

N/A (funding payments every hour)

Position limit

N/A

Account type

Per-wallet cross or isolated margin

Funding impact notional

20000 USDC for BTC and ETH

6000 USDC for all other assets 

Maximum market order value

$15,000,000 for max leverage >= 25, $5,000,000 for max leverage in [20, 25), $2,000,000 for max leverage in [10, 20), otherwise $500,000

Maximum limit order value

10 * maximum market order value

Trading
Margin tiers
Like most centralized exchanges, the tiered leverage formula on Hyperliquid is as follows:

maintenance_margin = notional_position_value * maintenance_margin_rate - maintenance_deduction 

On Hyperliquid, maintenance_margin_rate and maintenance_deduction depend only on the margin tiers, not the asset.

maintenance_margin_rate(tier = n) = (Initial Margin Rate at Maximum leverage at tier n) / 2 . For example, at 20x max leverage, maintenance_margin_rate = 2.5%.

Maintenance deduction is defined at each tier to account for the different maintenance margin rates used at previous tiers:

maintenance_deduction(tier = 0) = 0   

maintenance_deduction(tier = n) = maintenance_deduction(tier = n - 1) + notional_position_lower_bound(tier = n) * (maintenance_margin_rate(tier = n) - maintenance_margin_rate(tier = n - 1)) for n > 0 

In other words, maintenance deduction is defined so that new positions opened at each tier increase maintenance margin at maintenance_margin_rate , while having the total maintenance margin be a continuous function of position size.

Margin tables have unique IDs and the tiers can be found in the meta Info response.

Mainnet Margin Tiers
Mainnet margin tiers are enabled for the assets below:

BTC
Notional Position Value (USDC)
Max Leverage
0-150M

40

>150M

20

ETH
Notional Position Value (USDC)
Max Leverage
0-100M

25

>100M

15

SOL
Notional Position Value (USDC)
Max Leverage
0-70M

20

>70M

10

XRP
Notional Position Value (USDC)
Max Leverage
0-40M

20

>40M

10

DOGE, kPEPE, SUI, WLD, TRUMP, LTC, ENA, POPCAT, WIF, AAVE, kBONK, LINK, CRV, AVAX, ADA, UNI, NEAR, TIA, APT, BCH, HYPE, FARTCOIN
Notional Position Value (USDC)
Max Leverage
0-20M

10

>20M

5

OP, ARB, LDO, TON, MKR, ONDO, JUP, INJ, kSHIB, SEI, TRX, BNB, DOT
Notional Position Value (USDC)
Max Leverage
0-3M

10

>3M

5

Testnet Margin Tiers
The tiers on testnet are lower than mainnet would feature, for ease of testing. 

LDO, ARB, MKR, ATOM, PAXG, TAO, ICP, AVAX, FARTCOIN - testnet only
Notional Position Value (USDC)
Max Leverage
0-10k

10

>10k

5

DOGE, TIA, SUI, kSHIB, AAVE, TON - testnet only
Notional Position Value (USDC)
Max Leverage
0-20k

10

20-100k

5

>100k

3

ETH - testnet only
Notional Position Value (USDC)
Max Leverage
0-20k

25

20-50k

10

50-200k

5

>200k

3

BTC - testnet only
Notional Position Value (USDC)
Max Leverage
0-10k

40

10-50k

25

50-100k

10

100k-300k

5

>300k

3




Trading
Fees
Fees are based on your rolling 14 day volume and are assessed at the end of each day in UTC. Sub-account volume counts toward the master account and all sub-accounts share the same fee tier. Vault volume is treated separately from the master account. Referral rewards apply for a user's first $1B in volume and referral discounts apply for a user's first $25M in volume.

Maker rebates are paid out continuously on each trade directly to the trading wallet. Users can claim referral rewards from the Referrals page. 

There are separate fee schedules for perps vs spot. Perps and spot volume will be counted together to determine your fee tier, and spot volume will count double toward your fee tier. i.e., (14d weighted volume) = (14d perps volume) + 2 * (14d spot volume)

Perps fee tiers
Base rate
Diamond
Platinum
Gold
Silver
Bronze
Wood
Tier

14d weighted volume ($)

Taker

Maker

Taker

Maker

Taker

Maker

Taker

Maker

Taker

Maker

Taker

Maker

Taker

Maker

0

0.045%

0.015%

0.0270%

0.0090%

0.0315%

0.0105%

0.0360%

0.0120%

0.0383%

0.0128%

0.0405%

0.0135%

0.0428%

0.0143%

1

>5M

0.040%

0.012%

0.0240%

0.0072%

0.0280%

0.0084%

0.0320%

0.0096%

0.0340%

0.0102%

0.0360%

0.0108%

0.0380%

0.0114%

2

>25M

0.035%

0.008%

0.0210%

0.0048%

0.0245%

0.0056%

0.0280%

0.0064%

0.0298%

0.0068%

0.0315%

0.0072%

0.0333%

0.0076%

3

>100M

0.030%

0.004%

0.0180%

0.0024%

0.0210%

0.0028%

0.0240%

0.0032%

0.0255%

0.0034%

0.0270%

0.0036%

0.0285%

0.0038%

4

>500M

0.028%

0.000%

0.0168%

0.0000%

0.0196%

0.0000%

0.0224%

0.0000%

0.0238%

0.0000%

0.0252%

0.0000%

0.0266%

0.0000%

5

>2B

0.026%

0.000%

0.0156%

0.0000%

0.0182%

0.0000%

0.0208%

0.0000%

0.0221%

0.0000%

0.0234%

0.0000%

0.0247%

0.0000%

6

>7B

0.024%

0.000%

0.0144%

0.0000%

0.0168%

0.0000%

0.0192%

0.0000%

0.0204%

0.0000%

0.0216%

0.0000%

0.0228%

0.0000%

Spot fee tiers
Spot
Base rate
Diamond
Platinum
Gold
Silver
Bronze
Wood
Tier

14d weighted volume ($)

Taker

Maker

Taker

Maker

Taker

Maker

Taker

Maker

Taker

Maker

Taker

Maker

Taker

Maker

0

0.070%

0.040%

0.0420%

0.0240%

0.0490%

0.0280%

0.0560%

0.0320%

0.0595%

0.0340%

0.0630%

0.0360%

0.0665%

0.0380%

1

>5M

0.060%

0.030%

0.0360%

0.0180%

0.0420%

0.0210%

0.0480%

0.0240%

0.0510%

0.0255%

0.0540%

0.0270%

0.0570%

0.0285%

2

>25M

0.050%

0.020%

0.0300%

0.0120%

0.0350%

0.0140%

0.0400%

0.0160%

0.0425%

0.0170%

0.0450%

0.0180%

0.0475%

0.0190%

3

>100M

0.040%

0.010%

0.0240%

0.0060%

0.0280%

0.0070%

0.0320%

0.0080%

0.0340%

0.0085%

0.0360%

0.0090%

0.0380%

0.0095%

4

>500M

0.035%

0.000%

0.0210%

0.0000%

0.0245%

0.0000%

0.0280%

0.0000%

0.0298%

0.0000%

0.0315%

0.0000%

0.0333%

0.0000%

5

>2B

0.030%

0.000%

0.0180%

0.0000%

0.0210%

0.0000%

0.0240%

0.0000%

0.0255%

0.0000%

0.0270%

0.0000%

0.0285%

0.0000%

6

>7B

0.025%

0.000%

0.0150%

0.0000%

0.0175%

0.0000%

0.0200%

0.0000%

0.0213%

0.0000%

0.0225%

0.0000%

0.0238%

0.0000%

Staking tiers
Tier
HYPE staked
Trading fee discount
Wood

>10

5%

Bronze

>100

10%

Silver

>1,000

15%

Gold

>10,000

20%

Platinum

>100,000

30%

Diamond

>500,000

40%

Maker rebates
Tier
14d weighted maker volume
Maker fee
1

>0.5%

-0.001%

2

>1.5%

-0.002%

3

>3.0%

-0.003%

On most other protocols, the team or insiders are the main beneficiaries of fees. On Hyperliquid, fees are entirely directed to the community (HLP, the assistance fund, and spot deployers). Spot deployers may choose to keep up to 50% of trading fees generated by their token. For security, the assistance fund holds a majority of its assets in HYPE, which is the most liquid native asset on the Hyperliquid L1. The assistance fund uses the system address 0xfefefefefefefefefefefefefefefefefefefefe which operates entirely onchain as part of the L1 execution. The assistance fund requires validator quorum to use in special situations.

Staking linking
A "staking user" and a "trading user" can be linked so that the staking user's HYPE staked can be attributed to the trading user's fees. A few important points to note:

The staking user will be able to unilaterally control the trading user. In particular, linking to a specific staking user essentially gives them full control of funds in the trading account.

Linking is permanent. Unlinking is not supported.

The staking user will not receive any staking-related fee discount after being linked.

Linking requires the trading user to send an action first, and then the staking user to finalize the link. See "Link Staking" at app.hyperliquid.xyz/portfolio for details. 

No action is required if you plan to trade and stake from the same address. 



Trading
Builder codes
Note: The term "builder" in the context of builder codes does not refer to block builders within consensus, but rather "defi builders" who build applications on Hyperliquid.

Builder codes allow builders to receive a fee on fills that they send on behalf of a user. They are set per-order for maximal flexibility. The user must approve a maximum builder fee for each builder, and can revoke permissions at any time. Builder codes are processed entirely onchain as part of the fee logic.

In order to use builder codes, the end user would first approve a max fee for the builder address via the ApproveBuilderFee action. This action must be signed by the user's main wallet, not an agent/API wallet. The builder must have at least 100 USDC in perps account value. 

Builder codes currently only apply to fees that are collected in USDC, i.e. builder codes do not apply to the buying side of spot trades. Builder fees charged can be at most 0.1% on perps and 1% on spot.

Once the authorization is complete, future order actions sent on behalf of the user may include an optional builder parameter: {"b": address, "f": number}. b is the address of the builder and f is the builder fee to charge in tenths of basis points. I.e. a value of 10 means 1 basis point. 

Builders can claim fees from builder codes through the usual referral reward claim process.

For example code see the Python SDK https://github.com/hyperliquid-dex/hyperliquid-python-sdk/blob/master/examples/basic_builder_fee.py

API for builders
The approved maximum builder fee for a user can be queried via an info request {"type": "maxBuilderFee", "user": "0x...", "builder": "0x..."}.

The total builder fees collected for a builder is part of the referral state response from info request {"type": "referral", "user": "0x..."}.

The trades that use a particular builder code are uploaded in compressed LZ4 format to https://stats-data.hyperliquid.xyz/Mainnet/builder_fills/{builder_address}/{YYYYMMDD}.csv.lz4e.g. https://stats-data.hyperliquid.xyz/Mainnet/builder_fills/0x123.../20241031.csv.lz4 

Important: Note that these URLs are case sensitive, and require that builder_addressbe entirely lowercase. 


Trading
Order book
The order book works in essentially the same way as all centralized exchanges but is fully on-chain. Orders are added where price is an integer multiple of the tick size, and size is an integer multiple of lot size. The orders are matched in price-time priority. 

See this section for further details on order book implementation.




Trading
Order types
Order types:
Market: An order that executes immediately at the current market price

Limit: An order that executes at the selected limit price or better

Stop Market: A market order that is activated when the price reaches the selected stop price. Stop orders are generally used to help limit losses and lock in profits 

Stop Limit: A limit order that is activated when the price reaches the selected stop price 

Scale: Multiple limit orders in a set price range  

TWAP: A large order divided into smaller suborders and executed in 30 second intervals. TWAP suborders have a maximum slippage of 3% 

TWAP details: 
During execution, a TWAP order attempts to meet an execution target which is defined as the elapsed time divided by the total time times the total size. A suborder is sent every 30 seconds during the course of the TWAP. 

A suborder is constrained to have a max slippage of 3%. When suborders do not fully fill because of market conditions (e.g., wide spread, low liquidity, etc.), the TWAP may fall behind its execution target. In this case, the TWAP will try to catch up to this execution target during later suborders. These later suborders will be larger but subject to the constraint of 3 times the normal suborder size (defined as total TWAP size divided by number of suborders). It is possible that if too many suborders did not fill then the TWAP order may not fully catch up to the total size by the end. Like normal market orders, TWAP suborders do not fill during the post-only period of a network upgrade.

Order options:
Reduce Only: An order that reduces a current position as opposed to opening a new position in the opposite direction 

Good Til Cancel (GTC): An order that rests on the order book until it is filled or canceled 

Post Only (ALO): An order that is added to the order book but doesn‚Äôt execute immediately. It is only executed as a resting order

Immediate or Cancel (IOC): An order that will be canceled if it is not immediately filled

Take Profit: An order that triggers when the Take Profit (TP) price is reached.

Stop Loss: An order that triggers when the Stop Loss (SL) price is reached

TP and SL orders are often used by traders to set targets and protect profits or minimize losses on positions. TP and SL are automatically market orders. You can set a limit price and configure the amount of the position to have a TP or SL




Trading
Take profit and stop loss orders (TP/SL)
TP/SL orders close your position when a certain profit (resp. loss) has realized on your position.

The mark price is used to trigger TP/SL orders. 

TP/SL orders can be dragged on the TradingView chart. Note that dragging in a way that causes the order to immediately execute will lead to an error. Usually this prevents user mistakes, but if this is your desired behavior you can manually close the order from the position table or order form. 

Limit vs Market TP/SL orders
Users can choose between TP/SL market and limit orders. TP/SL market orders have a slippage tolerance of 10%.

By setting the limit price on TP/SL orders, users can control the slippage tolerance of a triggered order. The more aggressive the limit price, the more likely the TP/SL order will be filled upon triggering, but the higher the potential slippage upon filling. 

As a concrete example, a SL order to close a long with trigger price $10 and limit price $10 will hit the book when the mark price drops below $10. If the price drops from $11 to $9 instantly it is quite likely this SL order would rest at $10 instead of filling. However, if the limit price were $8 instead of $10, it's likely to fill at some price between $9 and $8. 

TP/SL associated with a position
TP/SL opened from the position form will have a size equal to the entire position by default. These orders will attempt to close the entire position at the time of trigger. If a specific size is configured on these TP/SL orders, they will be fixed-sized (i.e. they will not resize with the position after being placed).

Position TP/SL orders are the most beginner-friendly because they have simple placement and cancelation criteria.

TP/SL associated with a parent order (a.k.a one-cancels-other, OCO) 
This style of TP/SL is more complicated. Please read the below carefully to avoid unexpected outcomes.

TP/SL opened from the order form have a fixed size equal to the order they are tied to.

If the parent order is fully filled at placement, the children TP and/or SL orders are immediately placed. This behavior is similar to the TP/SL assocated with a position.

When the parent order is not fully filled, the children orders enter and untriggered state. The TP/SL orders have not been placed, and upon cancelation of an unfilled parent order, the child TP/SL orders will be canceled.

If the trader cancels a partially filled parent order, the child TP/SL orders are fully canceled as well. If the trader desires a TP/SL for the partially filled size, they must do so manually, e.g. by placing a separate TP/SL orders associated with the new position.

However, if the parent order is partially filled and then canceled due to insufficient margin, the TP/SL orders will be placed as if the order were fully filled. 

In conclusion, children TP/SL orders associated with a parent order will be placed if and only if the parent order fully fills or is partially filled followed by a cancelation for insufficient margin.   



Margining
Margin computations follow similar formulas to major centralized derivatives exchanges.

Margin Mode
When opening a position, a margin mode is selected. Cross margin is the default, which allows for maximal capital efficiency by sharing collateral between all other cross margin positions. Isolated margin is also supported, which allows an asset's collateral to be constrained to that asset. Liquidations in that asset do not affect other isolated positions or cross positions. Similarly, cross liquidations or other isolated liquidations do not affect the original isolated position.

Initial Margin and Leverage
Leverage can be set by a user to any integer between 1 and the max leverage. Max leverage depends on the asset. 

The margin required to open a position is position_size * mark_price / leverage. The initial margin is used by the position and cannot be withdrawn for cross margin positions. Isolated positions support adding and removing margin after opening the position. Unrealized pnl for cross margin positions will automatically be available as initial margin for new positions, while isolated positions will apply unrealized pnl as additional margin for the open position.

The leverage of an existing position can be increased without closing the position. Leverage is only checked upon opening a position. Afterwards, the user is responsible for monitoring the leverage usage to avoid liquidation. Possible actions to take on positions with negative unrealized pnl include partially or fully closing the position, adding margin (if isolated), and depositing USDC (if cross).

Unrealized PNL and transfer margin requirements
Unrealized pnl can be withdrawn from isolated positions or cross account, but only if the remaining margin is at least 10% of the total notional position value of all open positions. The margin remaining must also meet the initial margin requirement, i.e. transfer_margin_required = max(initial_margin_required, 0.1 * total_position_value) 

Here, "transferring" includes any action that removes margin from a position, other than trading. Examples include withdrawals, transfer to spot wallet, and isolated margin transfers.

Maintenance Margin and Liquidations
Cross positions are liquidated when the account value (including unrealized pnl) is less than the maintenance margin times the total open notional position. The maintenance margin is currently set to half of the initial margin at max leverage. 

Isolated positions are liquidated by the same maintenance margin logic, but the only inputs to the computation are the isolated margin and the notional value of the isolated position.



Trading
Liquidations
Overview
A liquidation event occurs when a trader's positions move against them to the point where the account equity falls below the maintenance margin. The maintenance margin is half of the initial margin at max leverage, which varies from 3-40x. In other words, the maintenance margin is between 1.25% (for 40x max leverage assets) and 16.7% (for 3x max leverage assets) depending on the asset.

When the account equity drops below maintenance margin, the positions are first attempted to be entirely closed by sending market orders to the book. The orders are for the full size of the position, and may be fully or partially closed. If the positions are entirely or partially closed such that the maintenance margin requirements are met, any remaining collateral remains with the trader.

If the account equity drops below 2/3 of the maintenance margin without successful liquidation through the book, a backstop liquidation happens through the liquidator vault. See Liquidator Vault explanation below for more details.

When a cross position is backstop liquidated, the trader's cross positions and cross margin are all transferred to the liquidator. In particular, if the trader has no isolated positions, the trader ends up with zero account equity.

When an isolated position is backstop liquidated, that isolated position and isolated margin are transferred to the liquidator. The user's cross margin and positions are untouched.

During backstop liquidation, the maintenance margin is not returned to the user. This is because the liquidator vault requires a buffer to make sure backstop liquidations are profitable on average. In order to avoid losing the maintenance margin, traders can place stop loss orders or exit the positions before the mark price reaches the liquidation price.

Liquidations use the mark price, which combines external CEX prices with Hyperliquid's book state. This makes liquidations more robust than using a single instantaneous book price. During times of high volatility or on highly leveraged positions, mark price may be significantly different from book price. It is recommended to use the exact formula for precise monitoring of liquidations.

Motivation
As described above, the majority of liquidations on Hyperliquid are sent directly to the order book. This allows all users to compete for the liquidation flow, and allows the liquidated user to keep any remaining margin. Unlike CEXs there is no clearance fee on liquidations. 

The resulting system is transparent and prioritizes retaining as much capital as possible for the liquidated user.

Partial Liquidations
For liquidatable positions larger than 100k USDC (10k USDC on testnet for easier testing), only 20% of the position will be sent as a market liquidation order to the book. After a block where any position of a user is partially liquidated, there is a cooldown period of 30 seconds. During this cooldown period, all market liquidation orders for that user will be for the entire position.

Liquidator Vault
Backstop liquidations on Hyperliquid are democratized through the liquidator vault, which is a component strategy of HLP. Positions that are below 2/3 of the maintenance margin can be taken over by the liquidator vault. 

On average, backstop liquidations are profitable for the liquidator. On most venues, this profit goes to the exchange operator or privileged market makers who internalize the flow. On Hyperliquid, the pnl stream from liquidations go entirely to the community through HLP. 

Computing Liquidation Price
When entering a trade, an estimated liquidation price is shown. This estimation may be inaccurate compared to the position's estimated liquidation price due to changing liquidity on the book.

Once a position is opened, a liquidation price is shown. This price has the certainty of the entry price, but still may not be the actual liquidation price due to funding payments or changes in unrealized pnl in other positions (for cross margin positions).

The actual liquidation price is independent on the leverage set for cross margin positions. A cross margin position at lower leverage simply uses more collateral.

The liquidation price does depend on leverage set for isolated margin positions, because the amount of isolated margin allocated depends on the initial margin set.

The precise formula for the liquidation price of a position is

liq_price = price - side * margin_available / position_size / (1 - l * side)

where

l = 1 / MAINTENANCE_LEVERAGE

side = 1 for long and -1 for short

margin_available (cross) = account_value - maintenance_margin_required

margin_available (isolated) = isolated_margin - maintenance_margin_required


Trading
Entry price and pnl
On the Hyperliquid DEX, entry price, unrealized pnl, and closed pnl are purely frontend components provided for user convenience. The fundamental accounting is based on margin (balance for spot) and trades. 

Perps
Perp trades are considered opening when the absolute value of the position increases. In other words, longing when already long or shorting when already short.

For opening trades, the entry price is updated to an average of current entry price and trade price weighted by size.

For closing trades, the entry price is kept the same.

Unrealized pnl is defined as side * (mark_price - entry_price) * position_size where side = 1 for a long position and side = -1 for a short position

Closed pnl is fee + side * (mark_price - entry_price) * position_size for a closing trade and only the fee for an opening trade.

Spot
Spot trades use the same formulas as perps with the following modifications: Spot trades are considered opening for buys and closing for sells. Transfers are treated as buys or sells at mark price, and genesis distributions are treated as having entry price at 10000 USDC market cap. Note that while 0 is the correct answer as genesis distributions are not bought, it leads to undefined return on equity. 

Pre-existing spot balances are assigned an entry price equal to the first trade or send after the feature was enabled around July 3 08:00 UTC.


Trading
Funding
Overview
Funding rates for crypto perpetual contracts are a mechanism that is used to ensure the price of the contract stays close to the underlying asset's price. 

The funding rate is a periodic fee that is paid by one side of the contract (either long or short) to the other side. Funding is purely peer-to-peer and no fees are collected on the payments.

The rate is calculated based on the difference between the contract's price and the spot price of the underlying asset. For consistency with CEXs, interest rate component is predetermined at 0.01% every 8 hours, which is 0.00125% every hour, or 11.6% APR paid to short. This represents the difference in cost to borrow USD versus spot crypto. 

The premium component fluctuates based on the difference between the perpetual contract's price and the underlying spot oracle price. If the contract's price is higher than the oracle price, the premium and hence the funding rate will be positive, and the long position will pay the short position. Conversely, if the contract's price is lower than the spot price, the funding rate will be negative, and the short position will pay the long position.

The funding rate on Hyperliquid is paid every hour. The funding rate is added or subtracted from the balance the contract holders at the funding interval.

Funding rates are designed to prevent large price disparities between the perpetual contract and the underlying asset. When the funding rate is high, it can incentivize traders to take the opposite position and help to bring the contract's price closer to the spot price of the underlying asset.

Technical details
Funding on Hyperliquid is designed to closely match the process used by centralized perpetual exchanges. 

The funding rate formula applies to 8 hour funding rate. However, funding is paid every hour at one eighth of the computed rate for each hour.

The specific formula is Funding Rate (F) = Average Premium Index (P) + clamp (interest rate - Premium Index (P), -0.0005, 0.0005). The premium is sampled every 5 seconds and averaged over the hour.

As described in the clearinghouse section, the oracle prices are computed by each validator as the weighted median of CEX spot prices for each asset, with weights depending on the liquidity of the CEX. 

premium = impact_price_difference / oracle_price 

where 

impact_price_difference = max(impact_bid_px - oracle_px, 0) - max(oracle_px - impact_ask_px, 0) 

and impact_bid_px and impact_ask_px are the average execution prices to tradeimpact_notional_usd on the bid and ask sides, respectively. See the contract specifications for the impact notional used, as well as other contract specific parameters.

Funding on Hyperliquid is capped at 4%/hour. Note that this is much less aggressive capping than CEX counterparts. The funding cap and funding interval do not depend on the asset. 

Note that the funding payment at the end of the interval is position_size * oracle_price * funding_rate. In particular, the spot oracle price is used to convert the position size to notional value, not the mark price.

Numerical Example
Here is an explicit example computation:

The interest rate is 0.01% (fixed).

The perpetual contract is trading at a premium, with the impact bid price being $10,100, and the spot price at $10,000.

The premium index is calculated as the difference between the two prices, which is $100 in this case.

The funding interval is 1 hour.

You hold a long position of 10 contracts, each representing 1 BTC.

First, calculate the premium:

Premium = (Impact bid price - Spot Price) / Spot Price = ($10,100 - $10,000) / $10,000 Premium = 0.01 (or 1%)

Next, clamp the interest rate minus the premium rate at 0.05%:

Clamped Difference = min(max(Interest Rate - Premium Rate, -0.05%), 0.05%) 

Clamped Difference = min(max(0.01% - 1%, -0.05%), 0.05%) 

Clamped Difference = min(max(-0.99%, -0.05%), 0.05%) Clamped Difference = -0.05%

Now, calculate the funding rate:

Funding Rate = Premium Rate + Clamped Difference Funding Rate = 1% + (-0.05%) 

Funding Rate = 0.95%

Previous
Entry price and pnl
Next

Trading
Miscellaneous UI
Max Drawdown
The max drawdown on the portfolio page is only used on the frontend for users' convenience. It does not affect any margining or computations on Hyperliquid. Users who care about the precise formula can get their account value and pnl history and compute it however they choose.

The formula used on the frontend is the maximum over times end > start of the value (pnl(end) - pnl(start)) / account_value(start) 

Note that the denominator is account value and the numerator is pnl. Also note that this not equal to absolute max drawdown divided by some account value. Each possible time range considered uses its own denominator. 


Trading
Auto-deleveraging
The liquidator has one last option to avoid liquidations that would cause a sufficiently large drawdown, at which point auto-deleveraging is triggered.

Auto-deleveraging strictly ensures that the platform stays solvent. If a user's account value or isolated position value becomes negative, the users on the opposite side of the position are ranked by unrealized pnl and leverage used. Those traders' positions are closed at the previous oracle price against the now underwater user, ensuring that the platform has no bad debt. 

Auto-deleveraging is an important final safeguard on the solvency of the platform. There is a strict invariant that under all operations, a user who has no open positions will not socialize any losses of the platform.




Trading
Robust price indices
Hyperliquid makes use of several robust prices based on order book and external data to minimize risk of market manipulation.

Oracle price is used to compute funding rates. This weighted median of CEX prices is robust because it does not depend on hyperliquid's market data at all. Oracle prices are updated by the validators approximately once every three seconds.

Mark price is the median of the following prices:

Oracle price plus a 150 second exponential moving average (EMA) of the difference between Hyperliquid's mid price and the oracle price

The median of best bid, best ask, last trade on Hyperliquid

Median of Binance, OKX, Bybit, Gate IO, MEXC perp mid prices with weights 3, 2, 2, 1, 1, respectively

If exactly two out of the three inputs above exist, the 30 second EMA of the median of best bid, best ask, and last trade on Hyperliquid is also added to the median inputs.

Mark price is an unbiased and robust estimate of the fair perp price, and is used for margining, liquidations, triggering TP/SL, and computing unrealized pnl. Mark price is updated whenever validators publish new oracle prices. Therefore, mark and oracle price are updated approximately once every 3 seconds.

The EMA update formula is defined as follows for an update value of sample at duration t since the last update

ema = numerator / denominator

numerator -> numerator * exp(-t / 2.5 minutes) + sample * t 

denominator -> denominator * exp(-t / 2.5 minutes) + t






Trading
Self-trade prevention
Trades between the same address cancel the resting order instead of causing a fill. No fees are deducted, nor does the the cancel show up in the trade feed.

On CEXs this behavior is often labeled as "expire maker." This is a commonly preferred behavior for market making algorithms, where the aggressing order would like to continue getting fills against liquidity behind the maker order up until the limit price.




Trading
Portfolio graphs
The portfolio page shows account value and P&L graphs on 24 hour, 7 day, and 30 day time horizons. 

Account value includes unrealized pnl from cross and isolated margin positions, as well as vault balances. 

Pnl is defined as account value plus net deposits, i.e. account value + deposits - withdrawals.

Note that these graphs are samples on deposits and withdrawals and also every 15 minutes. Therefore, they are not recommended to precise accounting purposes, as the interpolation between samples may not reflect the actual change in unrealized pnl in between two consecutive samples.





Trading
Hyperps
High level summary
Hyperps (Hyperliquid-only perps) trade like perpetual contracts that users are familiar with, but do not require an underlying spot or index oracle price. Instead, the funding rate is determined relative to a moving average hyperp mark price in place of the usual spot price. This makes the hyperp price more stable and less susceptible to manipulation, unlike usual pre-launch futures. 

This new derivative design does not require an underlying asset or index that exists at all points of the hyperp's lifetime, only that the underlying asset or index eventually exists for settlement or conversion. 

When trading hyperps, funding rates are very important to consider. If there is heavy price momentum in one direction, funding will heavily incentivize positions in the opposite direction for the next eight hours. As always, be sure to understand the contract before trading.

Conversion to vanilla perps
For a hyperp tracking ABC, shortly after when ABC/USDT is listed on Binance, OKX, or Bybit spot trading, ABC-USD will convert to a normal ABC-USD perp.

Hyperp mechanism details
Hyperps work just like normal perpetual contracts, except the external spot/index oracle price is replaced with an 8 hour exponentially weighted moving average of the last day's minutely mark prices. 

Precisely, oracle_price(t) = min[sum_{i=0}^1439 [(t - i minutes < t_list ? initial_mark_price : mark_price(t - i minutes)) * exp(-i/480)] * (1 - exp(-1/480)) / (1 - exp(-3)), intial_mark_price * 4]

Here a ? b : c evaluates to b if a is true and otherwise c.

Samples are taken on the first block after each unix minute, but the timestamps used are the nearest exact minute multiples. When there are fewer than 480 mark price samples, the initial mark price is used as the padding value.

Funding rate premium samples are computed as 5% of the usual clamped interest rate and premium formula. See Funding docs for more details.

Note that the oracle price is also restricted to be at most 4 times the one month average mark price as an additional safeguard against manipulation.





Market making
There is no DMM program, special rebates / fees, or latency advantages. Anyone is welcome to MM. You can find the Python SDK here: https://github.com/hyperliquid-dex/hyperliquid-python-sdk

If you have technical integration questions, it's recommended to start in the Discord channel for #api-traders: https://discord.gg/hyperliquid




Validators
Running a validator
GitHub repository for detailed instructions on how to run a non-validator and validator: https://github.com/hyperliquid-dex/node





Validators
Delegation program
Overview
Validators play a critical role in maintaining the integrity and efficiency of Hyperliquid. The Hyper Foundation Delegation Program is designed to: 

Enhance network security by delegating tokens to reliable and high-performing validators.

Promote diversity across the validator network to enhance decentralization.

Support validators committed to the growth and stability of the Hyperliquid ecosystem.

Testnet performance will be a criterion for mainnet delegation, particularly when mainnet performance metrics are not available for a given validator. Delegations will be monitored on an ongoing basis. The Foundation reserves the right to cease delegation at any time.

The Foundation validators will strongly consider participation in the Delegation Program as a factor for trusting peer validators. Those interested in running a mainnet validator are highly encouraged to apply for the Delegation Program before setting up a mainnet validator.

Eligibility
You must have 10k HYPE in one address before applying. The minimum self-delegation amount is 10k HYPE. Note that the minimum self-delegation amount is locked for one year.

You must run at least two non-validator nodes with 95% uptime if your application is accepted. The IP addresses of these nodes will be shared publicly and attributed to you on documentation pages. Others will use your non-validators as seed nodes to connect to. The IP addresses must be static, e.g. using elastic IP addresses on AWS. Important: Do not open any non-validator ports to the public until an announcement to open up mainnet non-validators. Never open validator ports to the public.

You must comply with applicable laws and regulations. 

You must successfully complete KYC/KYB processes. 

You must not be from a restricted jurisdiction, which includes, but is not limited to, Ontario, the U.S., Cuba, Iran, Myanmar, North Korea, Syria, and certain Russian-occupied regions of Ukraine. 

The Foundation reserves the right to adjust the above eligibility criteria at any time.

Apply
Fill out the application form.

Following review of your application, you may be invited to provide KYC/KYB details.

If your application is accepted and KYC/KYB is completed, you will need to review and accept the Program Terms.

Referrals
How do I refer someone to Hyperliquid?
You can create a referral code on https://app.hyperliquid.xyz/referrals after you‚Äôve done $10,000 in volume. You will receive a percent of referred users' fees, less any fee discount they receive. Referral rewards apply for a user's first $1B in volume and referral discounts apply for a user's first $25M in volume. 

Share your referral code with other traders using a unique link: app.hyperliquid.xyz/join/YOURCODE. 

How do I use a referral code?
Enter a referral code on https://app.hyperliquid.xyz/referrals or use a friend's referral link. Using a referral code will give you a 4% discount on your fees for your first $25M in volume. Referral discounts do not apply to vaults or sub-accounts because those are treated as independent accounts in the clearinghouse.




Referrals
Staking referral program
Note that this is not yet available on testnet or mainnet

Builder and referral codes on HyperCore will be upgraded with a staking referral program. Builders and referrers who stake HYPE will be able to keep a percentage of their referred users‚Äô trading fees, up to a maximum of 40% for builders and referrers at the highest staking tier. All builders and referrers with staked HYPE will automatically enjoy these benefits once the feature is enabled on mainnet.

Furthermore, builders and referrers will be able to share up to 50% of the staking referral revenue back to the referred user. This allows referrers to offer better than the default rates to new users.

What are builder codes and referral codes? 
Builder codes allow interfaces routing through Hyperliquid to charge a custom fee on a per-order basis. This additional fee is called a builder fee and goes 100% to the builder. The new staking referral program is strictly more revenue for builders.

Referral codes are applied when a user joins via a referral link. Unlike builder codes, referral codes are tied to users and apply regardless of how the user trades in perpetuity. Note that builder codes override referral codes for that order, and referral codes are disabled after the user trades $1B cumulative volume. 

How it works
The staking referral program interacts with staking tier fee discounts and the VIP tier fee schedule. If a builder or referrer has a higher staking tier than their referred user on a trade, they keep up to 100% of the difference. The percentage kept by the builder or referrer decreases as the volume tier of the referred user increases, starting at 100% for VIP 0 and ending at 40% for VIP 6. 

As an example: Alice has 100k staked HYPE, which gives a trading fee discount of 30%. Bob has 100 staked HYPE, which gives a trading fee discount of 10%, and Bob is at VIP 1. If Bob uses Alice‚Äôs builder or referral code, Alice can keep (30% - 10%) * 90% = 18% of the fees that Bob pays. Alice could share with Bob up to 9% of his fees. In other words, Bob could receive up to a 9% trading fee discount using Alice‚Äôs builder or referral code. 

VIP tier
14d weighted volume ($)
Amount kept by builder or referrer
0

100%

1

>5M

90%

2

>25M

80%

3

>100M

70%

4

>500M

60%

5

>2B

50%

6

>7B

40%

Note these tiers correspond to the fee schedules in Fees

Rollout
The staking referral program will be enabled in the coming days on testnet. The mainnet release will follow based on user feedback and stress testing. Note that the rollout on both testnet and mainnet will be incremental. In particular, the option to share up to 50% of staking referral revenue back to the referred users will come in a subsequent upgrade.



Points
The points program began on November 1, 2023. 1,000,000 points were distributed weekly to users for 6 months, ending May 1, 2024. Points are meant to reward users who contribute to the protocol‚Äôs success.

Affiliates earned 1 point for every 4 points their referred users earned. Points criteria was updated on a recurring basis. Points distributions were based on weekly activity ending Wednesdays at 00:00 UTC. Distributions took place on Thursdays. Points were also distributed for the closed alpha period up through October 31, 2023.

The L1 phase of points began on May 29, 2024 and ended in November 2024. 700,000 points were distributed weekly. Activity from May 1-28, 2024 received a multiplier. Hyperliquid reserves the right to modify previous point distributions under its sole discretion.


Historical data
The examples below use the AWS CLI (see https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html) and LZ4 (https://github.com/lz4/lz4 or install from your package manager).

Note that the requester of the data must pay for transfer costs.

Market data
Historical data is uploaded to the bucket hyperliquid-archive  approximately once a month. L2 book snapshots are available in market_data and asset contexts are available in asset_ctxs. No other historical data sets are provided via S3 (e.g. trades or data for spot markets). You can use the API to record additional historical data sets yourself. 

Format: s3://hyperliquid-archive/market_data/[date]/[hour]/[datatype]/[coin].lz4 or s3://hyperliquid-archive/asset_ctxs/[date].csv.lz4

Copy
aws s3 cp s3://hyperliquid-archive/market_data/20230916/9/l2Book/SOL.lz4 /tmp/SOL.lz4 --request-payer requester
unlz4 --rm /tmp/SOL.lz4
head /tmp/SOL
Historical node data
s3://hl-mainnet-node-data/explorer_blocksand s3://hl-mainnet-node-data/replica_cmds contain historical explorer blocks and L1 transactions.  

Previous
Points
Next



Risks
Smart contract risk
The onchain perp DEX depends on the correctness and security of the Arbitrum bridge smart contracts. Bugs or vulnerabilities in the smart contracts could result in the loss of user funds. 

L1 risk
Hyperliquid runs on its own L1 which has not undergone as extensive testing and scrutiny as other established L1s like Ethereum. The network may experience downtime due to consensus or other issues.

Market liquidity risk
As a relatively new protocol, there could be a potential risk of low liquidity, especially in the early stages. This can lead to significant price slippage for traders, negatively affecting the overall trading experience and possibly leading to substantial losses.

Oracle manipulation risk
Hyperliquid relies on price oracles maintained by the validators to supply market data. If an oracle is compromised or manipulated for an extended period of time, the mark price could be effected and liquidations could occur before the price reverts to its fair value.

Risk mitigation
There are additional measures in place to prevent oracle manipulation attacks on less liquid assets. One such restriction is open interest caps, which are based on a combination of liquidity, basis, and leverage in the system. 

When an asset hits the open interest cap, no new positions can be opened. Furthermore, orders cannot rest further than 1% from the oracle price. HLP is exempt from these rules in order to continue quoting liquidity.

Note that this is not an exhaustive list of potential risks. 


Bug bounty program
In scope
On mainnet, any bug that would cause an outage or logical error on nodes or API servers is in scope. 

On testnet, testnet-only features of the HyperEVM and its interaction with HyperCore are also in scope. Note that for features that are not live on mainnet, the bounty payment for EVM bugs will not match a mainnet bug of the same severity. 

Other experimental features on testnet are not in scope, unless otherwise announced, though bug reports are still appreciated for these features.

Submission process
Write a report regarding the bug and include detailed reproduction steps and a proof of concept to validate your findings. Submit your report to bugbounty@hyperfoundation.org.

If the same bug is reported by multiple individuals or entities, the first report will be honored. 

Rewards will be paid in USDC on Hyperliquid for responsible disclosure of bugs based on their severity. 

We agree not to pursue legal action in respect of any research conducted in good faith and in compliance with this program. 

The time and energy that go into all bug reports is deeply appreciated.

Prohibited activity 
Testing on mainnet code; all testing should be done on testnet or local forks.

Phishing or other social engineering attacks.

Extended, large scale DDOS attacks. Attacks involving mishandling of temporary spikes in load are allowed.

Testing with third-party systems and applications (e.g. browser extensions) as well as websites (e.g. SSO providers, advertising networks).

Submitting ransom demands or threats.

Publicly disclosing a bug report before it has been fixed and paid.

Threatening to publish or publishing anyone‚Äôs personally identifiable information or other sensitive information without their consent.

Exploiting vulnerabilities for personal financial gain beyond the rewards described in this program.

Attempting to bypass these procedures or engaging in unauthorized activities outside the outlined scope.

Eligibility
You must submit your report to bugbounty@hyperfoundation.org. Do not use external sites. 

You must comply with the KYC/KYB policy and procedures. 

You must be able to receive USDC on Hyperliquid. 

You must maintain confidentiality regarding vulnerabilities and communications until authorized for disclosure by us.

We must be able to reproduce your findings. All bounty submissions will be paid out based on their classification. Classification examples are subject to change.  

Contributors to the development of the code being tested are not eligible to participate in the program in relation to such code.

Ineligibility
Reports lacking sufficient detail, including step-by-step instructions, reproducible examples, or proof of concept.

Vulnerabilities that require highly unlikely or unreasonable user behavior to exploit.

Vulnerabilities caused by outdated software, unpatched browsers, or systems no longer supported by Hyperliquid.

Vulnerabilities that rely on root access, jailbreaking, or other modifications to user devices.

Issues within third-party libraries, extensions, tools, or applications that do not lead to a direct Hyperliquid vulnerability.

Bugs or errors unrelated to security, such as minor performance issues.

Bugs or errors contingent on extreme or unrealistic market conditions that do not reflect real-world scenarios.

General conditions
Payment will not be made for submissions that do not meet the program‚Äôs requirements or that are excluded under the program‚Äôs scope or ineligibility criteria. 

We reserve the right to determine the validity and classification of any submission at our sole discretion.

All submissions become the property of the Hyper Foundation. We reserve the right to use, modify, or disclose submissions for security purposes without requiring additional consent.

Classification examples
Critical (<1M USDC): Significant loss of user funds. Violation of L1 execution invariants.

High (<50k USDC): Network downtime that does not lead to incorrect state.

Medium (<10k USDC): API server performance issues. 

For the avoidance of doubt, rewards are determined based on the severity of the issue reported, and payouts may vary within the ranges listed above. Severity is determined based on both impact and likelihood of occurrence.


For developers
API
Documentation for the Hyperliquid public API

You can also use the API via the Hyperliquid Python SDK: https://github.com/hyperliquid-dex/hyperliquid-python-sdk

There is also a Rust SDK (although it is less maintained): https://github.com/hyperliquid-dex/hyperliquid-rust-sdk

There are also Typescript SDKs written by members of the community:
https://github.com/nktkas/hyperliquid
https://github.com/nomeida/hyperliquid
 

CCXT also maintains integrations in multiple languages that conforms with the standard CCXT API: https://docs.ccxt.com/#/exchanges/hyperliquid

All example API calls use the Mainnet url (https://api.hyperliquid.xyz), but you can make the same requests against Testnet using the corresponding url (https://api.hyperliquid-testnet.xyz)


For developers
API
Notation
The current v0 API currently uses some nonstandard notation. Relevant standardization will be batched into a breaking v1 API change.

Abbreviation
Full name
Explanation
Px

Price

Sz

Size

In units of coin, i.e. base currency

Szi

Signed size 

Positive for long, negative for short

Ntl

Notional

USD amount, Px * Sz 

Side

Side of trade or book

B = Bid = Buy, A = Ask = Short. Side is aggressing side for trades.

Asset

Asset

An integer representing the asset being traded. See below for explanation

Tif

Time in force

GTC = good until canceled, ALO = add liquidity only (post only), IOC = immediate or cancel


For developers
API
Asset IDs
Perpetual endpoints expect an integer for asset, which is the index of the coin found in the meta info response. E.g. BTC = 0 on mainnet.

Spot endpoints expect 10000 + spotInfo["index"] where spotInfo is the corresponding object in spotMeta that has the desired quote and base tokens. For example, when submitting an order for PURR/USDC, the asset that should be used is 10000 because its asset index in the spot info is 0.

Builder-deployed perps expect 100000 + perp_dex_index * 10000 + index_in_meta . For example, test:ABC on testnet has perp_dex_index = 1 ,index_in_meta = 0 , asset = 110000 . Note that builder-deployed perps always have name in the format {dex}:{coin} .

Examples
Note that spot ID is different from token ID, and that mainnet and testnet have different asset IDs. For example, for HYPE:

Mainnet token ID: 150

Mainnet spot ID: 107

Testnet token ID: 1105

Testnet spot ID: 1035



For developers
API
Tick and lot size
Both Price (px) and Size (sz) have a maximum number of decimals that are accepted. 

Prices can have up to 5 significant figures, but no more than MAX_DECIMALS - szDecimals decimal places where MAX_DECIMALS is 6 for perps and 8 for spot. Integer prices are always allowed, regardless of the number of significant figures. E.g. 123456 is a valid price even though 12345.6 is not.

Sizes are rounded to the szDecimals of that asset. For example, if szDecimals = 3 then 1.001 is a valid size but 1.0001 is not. 

szDecimals for an asset is found in the meta response to the info endpoint

Perp price examples
1234.5 is valid but 1234.56 is not (too many significant figures)

0.001234 is valid, but 0.0012345 is not (more than 6 decimal places)

If szDecimals = 1 , 0.01234 is valid but 0.012345 is not (more than 6 - szDecimals decimal places)

Spot price examples
0.0001234 is valid if szDecimals is 0 or 1, but not if szDecimals is greater than 2 (more than 8-2 decimal places). 

Signing
Note that if implementing signing, trailing zeroes should be removed. See Signing for more details.


For developers
API
Nonces and API wallets
Background 
A decentralized L1 must prevent replay attacks. When a user signs a USDC transfer transaction, the receiver cannot broadcast it multiple times to drain the sender's wallet. To solve this Ethereum stores a "nonce" for each address, which is a number that starts at 0. Each transaction must use exactly "nonce + 1" to be included.

API wallets
These are also known as agent wallets in the docs. A master account can approve API wallets to sign on behalf of the master account or any of the sub-accounts. 

Note that API wallets are only used to sign. To query the account data associated with a master or sub-account, you must pass in the actual address of that account. A common pitfall is to use the agent wallet which leads to an empty result.

API wallet pruning
API wallets and their associated nonce state may be pruned in the following cases:

The wallet is deregistered. This happens to an existing unnamed API Wallet when an ApproveAgent action is sent to register a new unnamed API Wallet. This also happens to an existing named API Wallet when an ApproveAgent action is sent with a matching name.

The wallet expires.

The account that registered the agent no longer has funds.

Important: for those using API wallets programmatically, it is strongly suggested to not reuse their addresses. Once an agent is deregistered, its used nonce state may be pruned. Generate a new agent wallet on future use to avoid unexpected behavior. For example, previously signed actions can be replayed once the nonce set is pruned.

Hyperliquid nonces 
Ethereum's design does not work for an onchain order book. A market making strategy can send thousands of orders and cancels in a second. Requiring a precise ordering of inclusion on the blockchain will break any strategy.

On Hyperliquid, the 100 highest nonces are stored per address. Every new transaction must have nonce larger than the smallest nonce in this set and also never have been used before. Nonces are tracked per signer, which is the user address if signed with private key of the address, or the agent address if signed with an API wallet. 

Nonces must be within (T - 2 days, T + 1 day), where T is the unix millisecond timestamp on the block of the transaction.

The following steps may help port over an automated strategy from a centralized exchange:

Use a API wallet per trading process. Note that nonces are stored per signer (i.e. private key), so separate subaccounts signed by the same API wallet will share the nonce tracker of the API wallet. It's recommended to use separate API wallets for different subaccounts.

In each trading process, have a task that periodically batches order and cancel requests every 0.1 seconds. It is recommended to batch IOC and GTC orders separately from ALO orders because ALO order-only batches are prioritized by the validators.

The trading logic tasks send orders and cancels to the batching task.

For each batch of orders or cancels, fetch and increment an atomic counter that ensures a unique nonce for the address. The atomic counter can be fast-forwarded to current unix milliseconds if needed.

This structure is robust to out-of-order transactions within 2 seconds, which should be sufficient for an automated strategy geographically near an API server.

Suggestions for subaccount and vault users
Note that nonces are stored per signer, which is the address of the private key used to sign the transaction. Therefore, it's recommended that each trading process or frontend session use a separate private key for signing. In particular, a single API wallet signing for a user, vault, or subaccount all share the same nonce set.

If users want to use multiple subaccounts in parallel, it would easier to generate two separate API wallets under the master account, and use one API wallet for each subaccount. This avoids collisions between the nonce set used by each subaccount.


For developers
API
Info endpoint
The info endpoint is used to fetch information about the exchange and specific users. The different request bodies result in different corresponding response body schemas.

Pagination
Responses that take a time range will only return 500 elements or distinct blocks of data. To query larger ranges, use the last returned timestamp as the next startTime for pagination.

Perpetuals vs Spot
The endpoints in this section as well as websocket subscriptions work for both Perpetuals and Spot. For perpetuals coin is the name returned in the meta response. For Spot, coin should be PURR/USDC for PURR, and @{index} e.g. @1 for all other spot tokens where index is the index of the spot pair in the universe field of the spotMeta response. For example, the spot index for HYPE on mainnet is @107 because the token index of HYPE is 150 and the spot pair @107 has tokens [150, 0].

User address
To query the account data associated with a master or sub-account, you must pass in the actual address of that account. A common pitfall is to use an agent wallet's address which leads to an empty result.

Retrieve mids for all coins
POST https://api.hyperliquid.xyz/info

Note that if the book is empty, the last trade price will be used as a fallback

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"allMids"

dex

String

Perp dex name. Defaults to the empty string which represents the first perp dex. Spot mids are only included with the first perp dex..

200: OK Successful Response
Copy
{
    "APE": "4.33245",
    "ARB": "1.21695"
}
Retrieve a user's open orders
POST https://api.hyperliquid.xyz/info

See a user's open orders

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"openOrders"

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

dex

String

Perp dex name. Defaults to the empty string which represents the first perp dex. Spot open orders are only included with the first perp dex.

200: OK Successful R
Copy
[
    {
        "coin": "BTC",
        "limitPx": "29792.0",
        "oid": 91490942,
        "side": "A",
        "sz": "0.0",
        "timestamp": 1681247412573
    }
]
Retrieve a user's open orders with additional frontend info
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"frontendOpenOrders"

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

dex

String

Perp dex name. Defaults to the empty string which represents the first perp dex. Spot open orders are only included with the first perp dex.

200: OK
Copy
[
    {
        "coin": "BTC",
        "isPositionTpsl": false,
        "isTrigger": false,
        "limitPx": "29792.0",
        "oid": 91490942,
        "orderType": "Limit",
        "origSz": "5.0",
        "reduceOnly": false,
        "side": "A",
        "sz": "5.0",
        "timestamp": 1681247412573,
        "triggerCondition": "N/A",
        "triggerPx": "0.0",
    }
]
Retrieve a user's fills
POST https://api.hyperliquid.xyz/info

Returns at most 2000 most recent fills

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"userFills"

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

aggregateByTime

bool

When true, partial fills are combined when a crossing order gets filled by multiple different resting orders. Resting orders filled by multiple crossing orders will not be aggregated.

200: OK
Copy
[
    // Perp fill
    {
        "closedPnl": "0.0",
        "coin": "AVAX",
        "crossed": false,
        "dir": "Open Long",
        "hash": "0xa166e3fa63c25663024b03f2e0da011a00307e4017465df020210d3d432e7cb8",
        "oid": 90542681,
        "px": "18.435",
        "side": "B",
        "startPosition": "26.86",
        "sz": "93.53",
        "time": 1681222254710,
        "fee": "0.01",
        "feeToken": "USDC",
        "builderFee": "0.01", // this is optional and will not be present if 0
        "tid": 118906512037719
    },
    // Spot fill - note the difference in the "coin" format. Refer to 
    // https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/asset-ids
    // for more information on how spot asset IDs work
    {
        "coin": "@107",
        "px": "18.62041381",
        "sz": "43.84",
        "side": "A",
        "time": 1735969713869,
        "startPosition": "10659.65434798",
        "dir": "Sell",
        "closedPnl": "8722.988077",
        "hash": "0x2222138cc516e3fe746c0411dd733f02e60086f43205af2ae37c93f6a792430b",
        "oid": 59071663721,
        "crossed": true,
        "fee": "0.304521",
        "tid": 907359904431134,
        "feeToken": "USDC"
    }
]
Retrieve a user's fills by time
POST https://api.hyperliquid.xyz/info

Returns at most 2000 fills per response and only the 10000 most recent fills are available

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

userFillsByTime

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

startTime*

int

Start time in milliseconds, inclusive

endTime

int

End time in milliseconds, inclusive. Defaults to current time.

aggregateByTime

bool

When true, partial fills are combined when a crossing order gets filled by multiple different resting orders. Resting orders filled by multiple crossing orders will not be aggregated.

200: OK Number of fills is limited to 2000
Copy
[
    // Perp fill
    {
        "closedPnl": "0.0",
        "coin": "AVAX",
        "crossed": false,
        "dir": "Open Long",
        "hash": "0xa166e3fa63c25663024b03f2e0da011a00307e4017465df020210d3d432e7cb8",
        "oid": 90542681,
        "px": "18.435",
        "side": "B",
        "startPosition": "26.86",
        "sz": "93.53",
        "time": 1681222254710,
        "fee": "0.01",
        "feeToken": "USDC",
        "builderFee": "0.01", // this is optional and will not be present if 0
        "tid": 118906512037719
    },
    // Spot fill - note the difference in the "coin" format. Refer to 
    // https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/asset-ids
    // for more information on how spot asset IDs work
    {
        "coin": "@107",
        "px": "18.62041381",
        "sz": "43.84",
        "side": "A",
        "time": 1735969713869,
        "startPosition": "10659.65434798",
        "dir": "Sell",
        "closedPnl": "8722.988077",
        "hash": "0x2222138cc516e3fe746c0411dd733f02e60086f43205af2ae37c93f6a792430b",
        "oid": 59071663721,
        "crossed": true,
        "fee": "0.304521",
        "tid": 907359904431134,
        "feeToken": "USDC"
    }
]
Query user rate limits
POST https://api.hyperliquid.xyz/info

Request Body
Name
Type
Description
user

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

type

String

userRateLimit

200: OK A successful response
Copy
{
  "cumVlm": "2854574.593578",
  "nRequestsUsed": 2890,
  "nRequestsCap": 2864574
}
Query order status by oid or cloid
POST https://api.hyperliquid.xyz/info

Request Body
Name
Type
Description
user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

type*

String

"orderStatus"

oid*

uint64 or string

Either u64 representing the order id or 16-byte hex string representing the client order id

The <status> string returned has the following possible values:

Order status
Explanation
open

Placed successfully

filled

Filled

canceled

Canceled by user

triggered

Trigger order triggered

rejected

Rejected at time of placement

marginCanceled

Canceled because insufficient margin to fill

vaultWithdrawalCanceled

Vaults only. Canceled due to a user's withdrawal from vault 

openInterestCapCanceled

Canceled due to order being too aggressive when open interest was at cap

selfTradeCanceled

Canceled due to self-trade prevention

reduceOnlyCanceled

Canceled reduced-only order that does not reduce position

siblingFilledCanceled

TP/SL only. Canceled due to sibling ordering being filled

delistedCanceled

Canceled due to asset delisting

liquidatedCanceled

Canceled due to liquidation

scheduledCancel

API only. Canceled due to exceeding scheduled cancel deadline (dead man's switch)

200: OK A successful response
200: OK Missing Order
Copy
{
  "status": "order",
  "order": {
    "order": {
      "coin": "ETH",
      "side": "A",
      "limitPx": "2412.7",
      "sz": "0.0",
      "oid": 1,
      "timestamp": 1724361546645,
      "triggerCondition": "N/A",
      "isTrigger": false,
      "triggerPx": "0.0",
      "children": [],
      "isPositionTpsl": false,
      "reduceOnly": true,
      "orderType": "Market",
      "origSz": "0.0076",
      "tif": "FrontendMarket",
      "cloid": null
    },
    "status": <status>,
    "statusTimestamp": 1724361546645
  }
}
L2 book snapshot
POST https://api.hyperliquid.xyz/info

Returns at most 20 levels per side

Headers

Name
Value
Content-Type*

"application/json"

Body

Name
Type
Description
type*

String

"l2Book"

coin*

String

coin

nSigFigs

Number

Optional field to aggregate levels to nSigFigs significant figures. Valid values are 2, 3, 4, 5, and null, which means full precision

mantissa

Number

Optional field to aggregate levels. This field is only allowed if nSigFigs is 5. Accepts values of 1, 2 or 5.

Response

200: OK
Copy
[
  [
    {
      "px": "19900",
      "sz": "1",
      "n": 1 // The number of different orders that comprise the level
    },
    {
      "px": "19800",
      "sz": "2",
      "n": 2
    },
    {
      "px": "19700",
      "sz": "3",
      "n": 3
    }
  ],
  [
    {
      "px": "20100",
      "sz": "1",
      "n": 1
    },
    {
      "px": "20200",
      "sz": "2",
      "n": 2
    },
    {
      "px": "20300",
      "sz": "3",
      "n": 3
    }
  ]
]
Candle snapshot
POST https://api.hyperliquid.xyz/info

Only the most recent 5000 candles are available

Headers

Name
Value
Content-Type*

"application/json"

Body

Name
Type
Description
type*

String

"candleSnapshot"

req*

Object

{"coin": <coin>, "interval": "15m", "startTime": <epoch millis>, "endTime": <epoch millis>}

Response

200: OK
Copy
[
  {
    "T": 1681924499999,
    "c": "29258.0",
    "h": "29309.0",
    "i": "15m",
    "l": "29250.0",
    "n": 189,
    "o": "29295.0",
    "s": "BTC",
    "t": 1681923600000,
    "v": "0.98639"
  }
]
Check builder fee approval
POST https://api.hyperliquid.xyz/info

Headers

Name
Value
Content-Type*

"application/json"

Body

Name
Type
Description
type*

String

"maxBuilderFee"

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

builder*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

Response

200: OK
Copy
1 // maximum fee approved in tenths of a basis point i.e. 1 means 0.001%
Retrieve a user's historical orders
POST https://api.hyperliquid.xyz/info

Returns at most 2000 most recent historical orders

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"historicalOrders"

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
[
  {
    "order": {
      "coin": "ETH",
      "side": "A",
      "limitPx": "2412.7",
      "sz": "0.0",
      "oid": 1,
      "timestamp": 1724361546645,
      "triggerCondition": "N/A",
      "isTrigger": false,
      "triggerPx": "0.0",
      "children": [],
      "isPositionTpsl": false,
      "reduceOnly": true,
      "orderType": "Market",
      "origSz": "0.0076",
      "tif": "FrontendMarket",
      "cloid": null
    },
    "status": "filled" | "open" | "canceled" | "triggered" | "rejected" | "marginCanceled",
    "statusTimestamp": 1724361546645
  }
]
Retrieve a user's TWAP slice fills
POST https://api.hyperliquid.xyz/info

Returns at most 2000 most recent TWAP slice fills

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"userTwapSliceFills"

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
[
    {
        "fill": {
            "closedPnl": "0.0",
            "coin": "AVAX",
            "crossed": true,
            "dir": "Open Long",
            "hash": "0x0000000000000000000000000000000000000000000000000000000000000000", // TWAP fills have a hash of 0
            "oid": 90542681,
            "px": "18.435",
            "side": "B",
            "startPosition": "26.86",
            "sz": "93.53",
            "time": 1681222254710,
            "fee": "0.01",
            "feeToken": "USDC",
            "tid": 118906512037719
        },
        "twapId": 3156
    }
]
Retrieve a user's subaccounts
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"subAccounts"

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
[
  {
    "name": "Test",
    "subAccountUser": "0x035605fc2f24d65300227189025e90a0d947f16c",
    "master": "0x8c967e73e6b15087c42a10d344cff4c96d877f1d",
    "clearinghouseState": {
      "marginSummary": {
        "accountValue": "29.78001",
        "totalNtlPos": "0.0",
        "totalRawUsd": "29.78001",
        "totalMarginUsed": "0.0"
      },
      "crossMarginSummary": {
        "accountValue": "29.78001",
        "totalNtlPos": "0.0",
        "totalRawUsd": "29.78001",
        "totalMarginUsed": "0.0"
      },
      "crossMaintenanceMarginUsed": "0.0",
      "withdrawable": "29.78001",
      "assetPositions": [],
      "time": 1733968369395
    },
    "spotState": {
      "balances": [
        {
          "coin": "USDC",
          "token": 0,
          "total": "0.22",
          "hold": "0.0",
          "entryNtl": "0.0"
        }
      ]
    }
  }
]
Retrieve details for a vault
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"vaultDetails"

vaultAddress*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

user

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
{
  "name": "Test",
  "vaultAddress": "0xdfc24b077bc1425ad1dea75bcb6f8158e10df303",
  "leader": "0x677d831aef5328190852e24f13c46cac05f984e7",
  "description": "This community-owned vault provides liquidity to Hyperliquid through multiple market making strategies, performs liquidations, and accrues platform fees.",
  "portfolio": [
    [
      "day",
      {
        "accountValueHistory": [
          [
            1734397526634,
            "329265410.90790099"
          ]
        ],
        "pnlHistory": [
          [
            1734397526634,
            "0.0"
          ],
        ],
        "vlm": "0.0"
      }
    ],
    [
      "week" | "month" | "allTime" | "perpDay" | "perpWeek" | "perpMonth" | "perpAllTime",
      {...}
    ]
  ],
  "apr": 0.36387129259090006,
  "followerState": null,
  "leaderFraction": 0.0007904828725729887,
  "leaderCommission": 0,
  "followers": [
    {
      "user": "0x005844b2ffb2e122cf4244be7dbcb4f84924907c",
      "vaultEquity": "714491.71026243",
      "pnl": "3203.43026143",
      "allTimePnl": "79843.74476743",
      "daysFollowing": 388,
      "vaultEntryTime": 1700926145201,
      "lockupUntil": 1734824439201
    }
  ],
  "maxDistributable": 94856870.164485,
  "maxWithdrawable": 742557.680863,
  "isClosed": false,
  "relationship": {
    "type": "parent",
    "data": {
      "childAddresses": [
        "0x010461c14e146ac35fe42271bdc1134ee31c703a",
        "0x2e3d94f0562703b25c83308a05046ddaf9a8dd14",
        "0x31ca8395cf837de08b24da3f660e77761dfb974b"
      ]
    }
  },
  "allowDeposits": true,
  "alwaysCloseOnWithdraw": false
}  
Retrieve a user's vault deposits
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"userVaultEquities"

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
[
  {
    "vaultAddress": "0xdfc24b077bc1425ad1dea75bcb6f8158e10df303",
    "equity": "742500.082809",
  }
]
Query a user's role
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"userRole"

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

User
Agent
Vault
Subaccount
Missing
Copy
{"role":"user"} # "missing", "user", "agent", "vault", or "subAccount"
Query a user's portfolio
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"portfolio"

user*

String

hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
[
  [
    "day",
    {
      "accountValueHistory": [
        [
          1741886630493,
          "0.0"
        ],
        [
          1741895270493,
          "0.0"
        ],
        ...
      ],
      "pnlHistory": [
        [
          1741886630493,
          "0.0"
        ],
        [
          1741895270493,
          "0.0"
        ],
        ...
      ],
      "vlm": "0.0"
    }
  ],
  ["week", { ... }],
  ["month", { ... }],
  ["allTime", { ... }],
  ["perpDay", { ... }],
  ["perpWeek", { ... }],
  ["perpMonth", { ... }],
  ["perpAllTime", { ... }]
]
Query a user's referral information
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"referral"

user*

String

hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
{
    "referredBy": {
        "referrer": "0x5ac99df645f3414876c816caa18b2d234024b487",
        "code": "TESTNET"
    },
    "cumVlm": "149428030.6628420055",
    "unclaimedRewards": "11.047361",
    "claimedRewards": "22.743781",
    "builderRewards": "0.027802",
    "referrerState": {
        "stage": "ready",
        "data": {
            "code": "TEST",
            "referralStates": [
                {
                    "cumVlm": "960652.017122",
                    "cumRewardedFeesSinceReferred": "196.838825",
                    "cumFeesRewardedToReferrer": "19.683748",
                    "timeJoined": 1679425029416,
                    "user": "0x11af2b93dcb3568b7bf2b6bd6182d260a9495728"
                },
                {
                    "cumVlm": "438278.672653",
                    "cumRewardedFeesSinceReferred": "97.628107",
                    "cumFeesRewardedToReferrer": "9.762562",
                    "timeJoined": 1679423947882,
                    "user": "0x3f69d170055913103a034a418953b8695e4e42fa"
                }
            ]
        }
    },
    "rewardHistory": []
}
Note that rewardHistory is for legacy rewards. Claimed rewards are now returned in nonFundingLedgerUpdate

Query a user's fees
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"userFees"

user*

String

hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
{
  "dailyUserVlm": [
    {
      "date": "2025-05-23",
      "userCross": "0.0",
      "userAdd": "0.0",
      "exchange": "2852367.0770729999"
    },
    ...
  ],
  "feeSchedule": {
    "cross": "0.00045",
    "add": "0.00015",
    "spotCross": "0.0007",
    "spotAdd": "0.0004",
    "tiers": {
      "vip": [
        {
          "ntlCutoff": "5000000.0",
          "cross": "0.0004",
          "add": "0.00012",
          "spotCross": "0.0006",
          "spotAdd": "0.0003"
        },
        ...
      ],
      "mm": [
        {
          "makerFractionCutoff": "0.005",
          "add": "-0.00001"
        },
        ...
      ]
    },
    "referralDiscount": "0.04",
    "stakingDiscountTiers": [
      {
        "bpsOfMaxSupply": "0.0",
        "discount": "0.0"
      },
      {
        "bpsOfMaxSupply": "0.0001",
        "discount": "0.05"
      },
      ...
    ]
  },
  "userCrossRate": "0.000315",
  "userAddRate": "0.000105",
  "userSpotCrossRate": "0.00049",
  "userSpotAddRate": "0.00028",
  "activeReferralDiscount": "0.0",
  "trial": null,
  "feeTrialReward": "0.0",
  "nextTrialAvailableTimestamp": null,
  "stakingLink": {
    "type": "tradingUser",
    "stakingUser": "0x54c049d9c7d3c92c2462bf3d28e083f3d6805061"
  },
  "activeStakingDiscount": {
    "bpsOfMaxSupply": "4.7577998927",
    "discount": "0.3"
  }
}
Query a user's staking delegations
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"delegations"

user*

String

hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
[
    {
        "validator":"0x5ac99df645f3414876c816caa18b2d234024b487",
        "amount":"12060.16529862",
        "lockedUntilTimestamp":1735466781353
    },
    ...
]
Query a user's staking summary
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"delegatorSummary"

user*

String

hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
{
    "delegated": "12060.16529862",
    "undelegated": "0.0",
    "totalPendingWithdrawal": "0.0",
    "nPendingWithdrawals": 0
}
Query a user's staking history
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"delegatorHistory"

user*

String

hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
[
    {
        "time": 1735380381353,
        "hash": "0x55492465cb523f90815a041a226ba90147008d4b221a24ae8dc35a0dbede4ea4",
        "delta": {
            "delegate": {
                "validator": "0x5ac99df645f3414876c816caa18b2d234024b487",
                "amount": "10000.0",
                "isUndelegate": false
            }
        }
    },
    ...
]
Query a user's staking rewards
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"delegatorRewards"

user*

String

hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK
Copy
[
    {
        "time": 1736726400073,
        "source": "delegation",
        "totalAmount": "0.73117184"
    },
    {
        "time": 1736726400073,
        "source": "commission",
        "totalAmount": "130.76445876"
    },
    ...
]










For developers
API
Info endpoint
Perpetuals
The section documents the info endpoints that are specific to perpetuals. See Rate limits section for rate limiting logic and weights.

Retrieve all perpetual dexs
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"perpDexs"

200: OK Successful Response
Copy
[
  null,
  {
    "name": "test",
    "full_name": "test dex",
    "deployer": "0x5e89b26d8d66da9888c835c9bfcc2aa51813e152",
    "oracle_updater": null
  }
]
Retrieve perpetuals metadata (universe and margin tables)
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"meta"

dex

String

Perp dex name. Defaults to the empty string which represents the first perp dex.

200: OK Successful Response
Copy
{
    "universe": [
        {
            "name": "BTC",
            "szDecimals": 5,
            "maxLeverage": 50
        },
        {
            "name": "ETH",
            "szDecimals": 4,
            "maxLeverage": 50
        },
        {
            "name": "HPOS",
            "szDecimals": 0,
            "maxLeverage": 3,
            "onlyIsolated": true
        },
        {
            "name": "LOOM",
            "szDecimals": 1,
            "maxLeverage": 3,
            "onlyIsolated": true,
            "isDelisted": true
        }
    ],
    "marginTables": [
        [
            50,
            {
                "description": "",
                "marginTiers": [
                    {
                        "lowerBound": "0.0",
                        "maxLeverage": 50
                    }
                ]
            }
        ],
        [
            51,
            {
                "description": "tiered 10x",
                "marginTiers": [
                    {
                        "lowerBound": "0.0",
                        "maxLeverage": 10
                    },
                    {
                        "lowerBound": "3000000.0",
                        "maxLeverage": 5
                    }
                ]
            }
        ]
    ]
}
Retrieve perpetuals asset contexts (includes mark price, current funding, open interest, etc.)
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"metaAndAssetCtxs"

200: OK Successful Response
Copy
[
{
     "universe": [
        {
            "name": "BTC",
            "szDecimals": 5,
            "maxLeverage": 50
        },
        {
            "name": "ETH",
            "szDecimals": 4,
            "maxLeverage": 50
        },
        {
            "name": "HPOS",
            "szDecimals": 0,
            "maxLeverage": 3,
            "onlyIsolated": true
        }
    ]
},
[
    {
        "dayNtlVlm":"1169046.29406",
         "funding":"0.0000125",
         "impactPxs":[
            "14.3047",
            "14.3444"
         ],
         "markPx":"14.3161",
         "midPx":"14.314",
         "openInterest":"688.11",
         "oraclePx":"14.32",
         "premium":"0.00031774",
         "prevDayPx":"15.322"
    },
    {
         "dayNtlVlm":"1426126.295175",
         "funding":"0.0000125",
         "impactPxs":[
            "6.0386",
            "6.0562"
         ],
         "markPx":"6.0436",
         "midPx":"6.0431",
         "openInterest":"1882.55",
         "oraclePx":"6.0457",
         "premium":"0.00028119",
         "prevDayPx":"6.3611"
      },
      {
         "dayNtlVlm":"809774.565507",
         "funding":"0.0000125",
         "impactPxs":[
            "8.4505",
            "8.4722"
         ],
         "markPx":"8.4542",
         "midPx":"8.4557",
         "openInterest":"2912.05",
         "oraclePx":"8.4585",
         "premium":"0.00033694",
         "prevDayPx":"8.8097"
      }
]
]
Retrieve user's perpetuals account summary
POST https://api.hyperliquid.xyz/info

See a user's open positions and margin summary for perpetuals trading

Headers
Name
Type
Description
Content-Type*

"application/json"

Request Body
Name
Type
Description
type*

String

"clearinghouseState"

user*

String

Onchain address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

dex

String

Perp dex name. Defaults to the empty string which represents the first perp dex.

200: OK Successful Response
Copy
{
  "assetPositions": [
    {
      "position": {
        "coin": "ETH",
        "cumFunding": {
          "allTime": "514.085417",
          "sinceChange": "0.0",
          "sinceOpen": "0.0"
        },
        "entryPx": "2986.3",
        "leverage": {
          "rawUsd": "-95.059824",
          "type": "isolated",
          "value": 20
        },
        "liquidationPx": "2866.26936529",
        "marginUsed": "4.967826",
        "maxLeverage": 50,
        "positionValue": "100.02765",
        "returnOnEquity": "-0.0026789",
        "szi": "0.0335",
        "unrealizedPnl": "-0.0134"
      },
      "type": "oneWay"
    }
  ],
  "crossMaintenanceMarginUsed": "0.0",
  "crossMarginSummary": {
    "accountValue": "13104.514502",
    "totalMarginUsed": "0.0",
    "totalNtlPos": "0.0",
    "totalRawUsd": "13104.514502"
  },
  "marginSummary": {
    "accountValue": "13109.482328",
    "totalMarginUsed": "4.967826",
    "totalNtlPos": "100.02765",
    "totalRawUsd": "13009.454678"
  },
  "time": 1708622398623,
  "withdrawable": "13104.514502"
}
Retrieve a user's funding history or non-funding ledger updates
POST https://api.hyperliquid.xyz/info

Note: Non-funding ledger updates include deposits, transfers, and withdrawals.

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"userFunding" or "userNonFundingLedgerUpdates"

user*

String

Address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

startTime*

int

Start time in milliseconds, inclusive

endTime

int

End time in milliseconds, inclusive. Defaults to current time.

200: OK Successful Response
Copy
[
    {
        "delta": {
            "coin":"ETH",
            "fundingRate":"0.0000417",
            "szi":"49.1477",
            "type":"funding",
            "usdc":"-3.625312"
        },
        "hash":"0xa166e3fa63c25663024b03f2e0da011a00307e4017465df020210d3d432e7cb8",
        "time":1681222254710
    },
    ...
]
Retrieve historical funding rates
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"fundingHistory"

coin*

String

Coin, e.g. "ETH"

startTime*

int

Start time in milliseconds, inclusive

endTime

int

End time in milliseconds, inclusive. Defaults to current time.

200: OK
Copy
[
    {
        "coin":"ETH",
        "fundingRate": "-0.00022196",
        "premium": "-0.00052196",
        "time":1683849600076
    }
]
Retrieve predicted funding rates for different venues
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"predictedFundings"

200: OK Successful Response
Copy
[
  [
    "AVAX",
    [
      [
        "BinPerp",
        {
          "fundingRate": "0.0001",
          "nextFundingTime": 1733961600000
        }
      ],
      [
        "HlPerp",
        {
          "fundingRate": "0.0000125",
          "nextFundingTime": 1733958000000
        }
      ],
      [
        "BybitPerp",
        {
          "fundingRate": "0.0001",
          "nextFundingTime": 1733961600000
        }
      ]
    ]
  ],...
]
Query perps at open interest caps
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"perpsAtOpenInterestCap"

200: OK Successful Response
Copy
["BADGER","CANTO","FTM","LOOM","PURR"]
Retrieve information about the Perp Deploy Auction
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"perpDeployAuctionStatus"

200: OK Successful Response
Copy
{
  "startTimeSeconds": 1747656000,
  "durationSeconds": 111600,
  "startGas": "500.0",
  "currentGas": "500.0",
  "endGas": null
}




Spot
The section documents the info endpoints that are specific to spot.

Retrieve spot metadata
POST https://api.hyperliquid.xyz/info

Headers

Name
Value
Content-Type*

"application/json"

Body

Name
Type
Description
type*

String

"spotMeta"

Response

200: OK Successful Response
Copy
{
    "tokens": [
        {
            "name": "USDC",
            "szDecimals": 8,
            "weiDecimals" 8,
            "index": 0,
            "tokenId": "0x6d1e7cde53ba9467b783cb7c530ce054",
            "isCanonical": true,
            "evmContract":null,
            "fullName":null
        },
        {
            "name": "PURR",
            "szDecimals": 0,
            "weiDecimals": 5,
            "index": 1,
            "tokenId": "0xc1fb593aeffbeb02f85e0308e9956a90",
            "isCanonical": true,
            "evmContract":null,
            "fullName":null
        },
        {
            "name": "HFUN",
            "szDecimals": 2,
            "weiDecimals": 8,
            "index": 2,
            "tokenId": "0xbaf265ef389da684513d98d68edf4eae",
            "isCanonical": false,
            "evmContract":null,
            "fullName":null
        },
    ],
    "universe": [
        {
            "name": "PURR/USDC",
            "tokens": [1, 0],
            "index": 0,
            "isCanonical": true
        },
        {
            "tokens": [2, 0],
            "name": "@1",
            "index": 1,
            "isCanonical": false
        },
    ]
}
Retrieve spot asset contexts
POST https://api.hyperliquid.xyz/info

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
type*

String

"spotMetaAndAssetCtxs"

200: OK Successful Response
Copy
[
{
    "tokens": [
        {
            "name": "USDC",
            "szDecimals": 8,
            "weiDecimals" 8,
            "index": 0,
            "tokenId": "0x6d1e7cde53ba9467b783cb7c530ce054",
            "isCanonical": true,
            "evmContract":null,
            "fullName":null
        },
        {
            "name": "PURR",
            "szDecimals": 0,
            "weiDecimals": 5,
            "index": 1,
            "tokenId": "0xc1fb593aeffbeb02f85e0308e9956a90",
            "isCanonical": true,
            "evmContract":null,
            "fullName":null
        }
    ],
    "universe": [
        {
            "name": "PURR/USDC",
            "tokens": [1, 0],
            "index": 0,
            "isCanonical": true
        }
    ]
},
[
    {
        "dayNtlVlm":"8906.0",
        "markPx":"0.14",
        "midPx":"0.209265",
        "prevDayPx":"0.20432"
    }
]
]
Retrieve a user's token balances
POST https://api.hyperliquid.xyz/info

See a user's token balances

Headers
Name
Type
Description
Content-Type*

"application/json"

Request Body
Name
Type
Description
type*

String

"spotClearinghouseState"

user*

String

Onchain address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

200: OK Successful Response
Copy
{
    "balances": [
        {
            "coin": "USDC",
            "token": 0,
            "hold": "0.0",
            "total": "14.625485",
            "entryNtl": "0.0"
        },
        {
            "coin": "PURR",
            "token": 1,
            "hold": "0",
            "total": "2000",
            "entryNtl": "1234.56",
        }
    ]
}
Retrieve information about the Spot Deploy Auction
POST https://api.hyperliquid.xyz/info

Headers

Name
Value
Content-Type*

"application/json"

Body

Name
Type
Description
type*

String

"spotDeployState"

user*

String

Onchain address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000.

Response

200: OK Successful Response
Copy
{
  "states": [
    {
      "token": 150,
      "spec" : {
        "name": "HYPE",
        "szDecimals": 2,
        "weiDecimals": 8,
      },
      "fullName": "Hyperliquid",
      "spots": [107],
      "maxSupply": 1000000000,
      "hyperliquidityGenesisBalance": "120000",
      "totalGenesisBalanceWei": "100000000000000000",
      "userGenesisBalances": [
        ("0xdddddddddddddddddddddddddddddddddddddddd", "428,062,211")...
      ],
      "existingTokenGenesisBalances": [
        (1, "0")...
      ]
    }
  ],
  "gasAuction": {
    "startTimeSeconds": 1733929200,
    "durationSeconds": 111600,
    "startGas": "181305.90046",
    "currentGas": null,
    "endGas": "181291.247358"
  }
}
Retrieve information about a token
POST https://api.hyperliquid.xyz/info

Headers

Name
Value
Content-Type*

"application/json"

Body

Name
Type
Description
type*

String

"tokenDetails"

tokenId*

String

Onchain id in 34-character hexadecimal format; e.g. 0x00000000000000000000000000000000.

Response

200: OK Successful Response
Copy
{
  "name": "TEST",
  "maxSupply": "1852229076.12716007",
  "totalSupply": "851681534.05516005",
  "circulatingSupply": "851681534.05516005",
  "szDecimals": 0,
  "weiDecimals": 5,
  "midPx": "3.2049",
  "markPx": "3.2025",
  "prevDayPx": "3.2025",
  "genesis": {
    "userBalances": [
      [
        "0x0000000000000000000000000000000000000001",
        "1000000000.0"
      ],
      [
        "0xffffffffffffffffffffffffffffffffffffffff",
        "1000000000.0"
      ]
    ],
    "existingTokenBalances": []
  },
  "deployer": "0x0000000000000000000000000000000000000001",
  "deployGas": "100.0",
  "deployTime": "2024-06-05T10:50:59.434",
  "seededUsdc": "0.0",
  "nonCirculatingUserBalances": [],
  "futureEmissions": "0.0"
}







For developers
API
Exchange endpoint
The exchange endpoint is used to interact with and trade on the Hyperliquid chain. See the Python SDK for code to generate signatures for these requests.

Asset
Many of the requests take asset as an input. For perpetuals this is the index in the universe field returned by themeta response. For spot assets, use 10000 + index where index is the corresponding index in spotMeta.universe. For example, when submitting an order for PURR/USDC, the asset that should be used is 10000 because its asset index in the spot metadata is 0.

Subaccounts and vaults
Subaccounts and vaults do not have private keys. To perform actions on behalf of a subaccount or vault signing should be done by the master account and the vaultAddress field should be set to the address of the subaccount or vault. The basic_vault.py example in the Python SDK demonstrates this.

Expires After
Some actions support an optional field expiresAfter which is a timestamp in milliseconds after which the action will be rejected. User-signed actions such as Core USDC transfer do not support the expiresAfter field. Note that actions consume 5x the usual address-based rate limit when canceled due to a stale expiresAfter field. 

See the Python SDK for details on how to incorporate this field when signing. 

Place an order
POST https://api.hyperliquid.xyz/exchange

See Python SDK for full featured examples on the fields of the order request.

For limit orders, TIF (time-in-force) sets the behavior of the order upon first hitting the book.

ALO (add liquidity only, i.e. "post only") will be canceled instead of immediately matching.

IOC (immediate or cancel) will have the unfilled part canceled instead of resting.

GTC (good til canceled) orders have no special behavior.

Client Order ID (cloid) is an optional 128 bit hex string, e.g. 0x1234567890abcdef1234567890abcdef

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "order",
  "orders": [{

    "a": Number,

    "b": Boolean,

    "p": String,

    "s": String,

    "r": Boolean,

    "t": {

      "limit": {

        "tif": "Alo" | "Ioc" | "Gtc" 

      } or

      "trigger": {

         "isMarket": Boolean,

         "triggerPx": String,

         "tpsl": "tp" | "sl"

       }

    },

    "c": Cloid (optional)

  }],

  "grouping": "na" | "normalTpsl" | "positionTpsl",

  "builder": Optional({"b": "address", "f": Number})

}

Meaning of keys:
a is asset
b is isBuy
p is price
s is size
r is reduceOnly
t is type
c is cloid (client order id)

Meaning of keys in optional builder argument:
b is the address the should receive the additional fee
f is the size of the fee in tenths of a basis point e.g. if f is 10, 1bp of the order notional  will be charged to the user and sent to the builder

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

vaultAddress

String

If trading on behalf of a vault or subaccount, its Onchain address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

expiresAfter

Number

Timestamp in milliseconds

200: OK Successful Response (resting)
200: OK Error Response
200: OK Successful Response (filled)
Copy
{
   "status":"ok",
   "response":{
      "type":"order",
      "data":{
         "statuses":[
            {
               "resting":{
                  "oid":77738308
               }
            }
         ]
      }
   }
}
Cancel order(s)
POST https://api.hyperliquid.xyz/exchange

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "cancel",

  "cancels": [

    {

      "a": Number,

      "o": Number

    }

  ]

}

Meaning of keys:
a is asset
o is oid (order id)

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

vaultAddress

String

If trading on behalf of a vault or subaccount, its address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

expiresAfter

Number

Timestamp in milliseconds

200: OK Successful Response
200: OK Error Response
Copy
{
   "status":"ok",
   "response":{
      "type":"cancel",
      "data":{
         "statuses":[
            "success"
         ]
      }
   }
}
Cancel order(s) by cloid
POST https://api.hyperliquid.xyz/exchange 

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "cancelByCloid",

  "cancels": [

    {

      "asset": Number,

      "cloid": String

    }

  ]

}

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

vaultAddress

String

If trading on behalf of a vault or subaccount, its address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

expiresAfter

Number

Timestamp in milliseconds

200: OK Successful Response
200: OK Error Response
Schedule cancel (dead man's switch)
POST https://api.hyperliquid.xyz/exchange 

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "scheduleCancel",

  "time": number (optional)

}

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

vaultAddress

String

If trading on behalf of a vault or subaccount, its address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

expiresAfter

Number

Timestamp in milliseconds

Schedule a cancel-all operation at a future time. Not including time will remove the scheduled cancel operation. The time must be at least 5 seconds after the current time. Once the time comes, all open orders will be canceled and a trigger count will be incremented. The max number of triggers per day is 10. This trigger count is reset at 00:00 UTC.

Modify an order
POST https://api.hyperliquid.xyz/exchange  

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "modify",

  "oid": Number | Cloid,

  "order": {

    "a": Number,

    "b": Boolean,

    "p": String,

    "s": String,

    "r": Boolean,

    "t": {

      "limit": {

        "tif": "Alo" | "Ioc" | "Gtc" 

      } or

      "trigger": {

         "isMarket": Boolean,

         "triggerPx": String,

         "tpsl": "tp" | "sl"

       }

    },

    "c": Cloid (optional)

  }

}

Meaning of keys:
a is asset
b is isBuy
p is price
s is size
r is reduceOnly
t is type
c is cloid (client order id)

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

vaultAddress

String

If trading on behalf of a vault or subaccount, its Onchain address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

expiresAfter

Number

Timestamp in milliseconds

200: OK Successful Response
200: OK Error Response
Modify multiple orders
POST https://api.hyperliquid.xyz/exchange

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "batchModify",

  "modifies": [{

    "oid": Number | Cloid,

    "order": {

      "a": Number,

      "b": Boolean,

      "p": String,

      "s": String,

      "r": Boolean,

      "t": {

        "limit": {

          "tif": "Alo" | "Ioc" | "Gtc" 

        } or

        "trigger": {

           "isMarket": Boolean,

           "triggerPx": String,

           "tpsl": "tp" | "sl"

         }

      },

      "c": Cloid (optional)

    }

  }]

}

Meaning of keys:
a is asset
b is isBuy
p is price
s is size
r is reduceOnly
t is type
c is cloid (client order id)

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

vaultAddress

String

If trading on behalf of a vault or subaccount, its Onchain address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

expiresAfter

Number

Timestamp in milliseconds

Update leverage
POST https://api.hyperliquid.xyz/exchange

Update cross or isolated leverage on a coin. 

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "updateLeverage",

  "asset": index of coin,

  "isCross": true or false if updating cross-leverage,

  "leverage": integer representing new leverage, subject to leverage constraints on that coin

}

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

vaultAddress

String

If trading on behalf of a vault or subaccount, its Onchain address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

expiresAfter

Number

Timestamp in milliseconds

200: OK Successful response
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Update isolated margin
POST https://api.hyperliquid.xyz/exchange

Add or remove margin from isolated position

Note that to target a specific leverage instead of a USDC value of margin change, there is an alternate action {"type": "topUpIsolatedOnlyMargin", "asset": <asset>, "leverage": <float string>}

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "updateIsolatedMargin",

  "asset": index of coin,

  "isBuy": true, (this parameter won't have any effect until hedge mode is introduced)

  "ntli": int representing amount to add or remove with 6 decimals, e.g. 1000000 for 1 usd,

}

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

vaultAddress

String

If trading on behalf of a vault or subaccount, its Onchain address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

expiresAfter

Number

Timestamp in milliseconds

200: OK Successful response
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Core USDC transfer
POST https://api.hyperliquid.xyz/exchange

Send usd to another address. This transfer does not touch the EVM bridge. The signature format is human readable for wallet interfaces.

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "usdSend",

  "hyperliquidChain": "Mainnet" (on testnet use "Testnet" instead),
  "signatureChainId": the id of the chain used when signing in hexadecimal format; e.g. "0xa4b1" for Arbitrum,

  "destination": address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000,

   "amount": amount of usd to send as a string, e.g. "1" for 1 usd,

     "time": current timestamp in milliseconds as a Number, should match nonce

}

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

200: OK Successful Response
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Core spot transfer
POST https://api.hyperliquid.xyz/exchange

Send spot assets to another address. This transfer does not touch the EVM bridge. The signature format is human readable for wallet interfaces.

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "spotSend",

  "hyperliquidChain": "Mainnet" (on testnet use "Testnet" instead),
  "signatureChainId": the id of the chain used when signing in hexadecimal format; e.g. "0xa4b1" for Arbitrum,

  "destination": address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000,
  "token": tokenName:tokenId, e.g. "PURR:0xc4bf3f870c0e9465323c0b6ed28096c2"

   "amount": amount of token to send as a string, e.g. "0.01",

     "time": current timestamp in milliseconds as a Number, should match nonce

}

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

200: OK Successful Response
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Copy
Example sign typed data for generating the signature:
{
  "types": {
    "HyperliquidTransaction:SpotSend": [
      {
        "name": "hyperliquidChain",
        "type": "string"
      },
      {
        "name": "destination",
        "type": "string"
      },
      {
        "name": "token",
        "type": "string"
      },
      {
        "name": "amount",
        "type": "string"
      },
      {
        "name": "time",
        "type": "uint64"
      }
    ]
  },
  "primaryType": "HyperliquidTransaction:SpotSend",
  "domain": {
    "name": "HyperliquidSignTransaction",
    "version": "1",
    "chainId": 42161,
    "verifyingContract": "0x0000000000000000000000000000000000000000"
  },
  "message": {
    "destination": "0x0000000000000000000000000000000000000000",
    "token": "PURR:0xc1fb593aeffbeb02f85e0308e9956a90",
    "amount": "0.1",
    "time": 1716531066415,
    "hyperliquidChain": "Mainnet"
  }
}
Initiate a withdrawal request
POST https://api.hyperliquid.xyz/exchange

This method is used to initiate the withdrawal flow. After making this request, the L1 validators will sign and send the withdrawal request to the bridge contract. There is a $1 fee for withdrawing at the time of this writing and withdrawals take approximately 5 minutes to finalize.

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{
  "type": "withdraw3",

  "hyperliquidChain": "Mainnet" (on testnet use "Testnet" instead),
  "signatureChainId": the id of the chain used when signing in hexadecimal format; e.g. "0xa4b1" for Arbitrum,

  "amount": amount of usd to send as a string, e.g. "1" for 1 usd,

  "time": current timestamp in milliseconds as a Number, should match nonce,

  "destination": address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

}

nonce*

Number

Recommended to use the current timestamp in milliseconds, must match the nonce in the action Object above

signature*

Object

200: OK
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Transfer from Spot account to Perp account (and vice versa)
POST https://api.hyperliquid.xyz/exchange

This method is used to transfer USDC from the user's spot wallet to perp wallet and vice versa.

Headers

Name
Value
Content-Type*

"application/json"

Body

Name
Type
Description
action*

Object

{

  "type": "usdClassTransfer",

  "hyperliquidChain": "Mainnet" (on testnet use "Testnet" instead),
  "signatureChainId": the id of the chain used when signing in hexadecimal format; e.g. "0xa4b1" for Arbitrum,

 "amount": amount of usd to transfer as a string, e.g. "1" for 1 usd. If you want to use this action for a subaccount, you can include subaccount: address after the amount, e.g. "1" subaccount:0x0000000000000000000000000000000000000000,

  "toPerp": True if (spot -> perp) else False,

"nonce": current timestamp in milliseconds as a Number, must match nonce in outer request body

}

nonce*

Number

Recommended to use the current timestamp in milliseconds, must match the nonce in the action Object above

signature*

Object

Response

200: OK
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Transfer from Spot account to Perp account for Builder-Deployed Dex (and vice versa)  
POST https://api.hyperliquid.xyz/exchange

This method is used to transfer collateral tokens from the user's spot wallet to a builder-deployed perp dex wallet and vice versa.

Headers
Name
Value
Content-Type*

application/json

Body
Name
Type
Description
action*

Object

{

  "type": "PerpDexClassTransfer",

  "hyperliquidChain": "Mainnet" (on testnet use "Testnet" instead),
  "signatureChainId": the id of the chain used when signing in hexadecimal format; e.g. "0xa4b1" for Arbitrum,

 "dex": name of perp dex,

 "token": collateral token of the perp dex as a string,

 "amount": amount of collateral token to transfer as a string, e.g. "1" for 1 usd. If you want to use this action for a subaccount, you can include subaccount: address after the amount, e.g. "1" subaccount:0x0000000000000000000000000000000000000000,

  "toPerp": True if (spot -> perp) else False,

"nonce": current timestamp in milliseconds as a Number, must match nonce in outer request body

}

nonce*

Number

Recommended to use the current timestamp in milliseconds, must match the nonce in the action Object above

signature*

Object

Response
200: OK
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Deposit into staking
POST https://api.hyperliquid.xyz/exchange

This method is used to transfer native token from the user's spot account into staking for delegating to validators. 

Headers
Name
Value
Content-Type*

application/json

Body
Name
Type
Description
action*

Object

{

  "type": "cDeposit",

  "hyperliquidChain": "Mainnet" (on testnet use "Testnet" instead),
  "signatureChainId": the id of the chain used when signing in hexadecimal format; e.g. "0xa4b1" for Arbitrum,

 "wei": amount of wei to transfer as a number,

"nonce": current timestamp in milliseconds as a Number, must match nonce in outer request body

}

nonce*

Number

Recommended to use the current timestamp in milliseconds, must match the nonce in the action Object above

signature*

Object

Response
200: OK
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Withdraw from staking
POST https://api.hyperliquid.xyz/exchange

This method is used to transfer native token from staking into the user's spot account. Note that transfers from staking to spot account go through a 7 day unstaking queue.

Headers
Name
Value
Content-Type*

application/json

Body
Name
Type
Description
action*

Object

{

  "type": "cWithdraw",

  "hyperliquidChain": "Mainnet" (on testnet use "Testnet" instead),
  "signatureChainId": the id of the chain used when signing in hexadecimal format; e.g. "0xa4b1" for Arbitrum,

 "wei": amount of wei to transfer as a number,

"nonce": current timestamp in milliseconds as a Number, must match nonce in outer request body

}

nonce*

Number

Recommended to use the current timestamp in milliseconds, must match the nonce in the action Object above

signature*

Object

Response
200: OK
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Delegate or undelegate stake from validator
POST https://api.hyperliquid.xyz/exchange

Delegate or undelegate native tokens to or from a validator. Note that delegations to a particular validator have a lockup duration of 1 day.

Headers
Name
Value
Content-Type*

application/json

Body
Name
Type
Description
action*

Object

{

  "type": "tokenDelegate",

  "hyperliquidChain": "Mainnet" (on testnet use "Testnet" instead),
  "signatureChainId": the id of the chain used when signing in hexadecimal format; e.g. "0xa4b1" for Arbitrum,

  "validator": address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000,
"isUndelegate": boolean,

"wei": number,

"nonce": current timestamp in milliseconds as a Number, must match nonce in outer request body

}

nonce*

number

Recommended to use the current timestamp in milliseconds

signature*

Object

Response
200: OK
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Deposit or withdraw from a vault
POST https://api.hyperliquid.xyz/exchange

Add or remove funds from a vault.

Headers

Name
Value
Content-Type*

application/json

Body

Name
Type
Description
action*

Object

{

  "type": "vaultTransfer",

  "vaultAddress": address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000,
"isDeposit": boolean,

"usd": number

}

nonce*

number

Recommended to use the current timestamp in milliseconds

signature*

Object

expiresAfter

Number

Timestamp in milliseconds

Response

200
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Approve an API wallet
POST https://api.hyperliquid.xyz/exchange

Approves an API Wallet (also sometimes referred to as an Agent Wallet). See here for more details.

Headers

Name
Value
Content-Type*

application/json

Body

Name
Type
Description
action*

Object

{
  "type": "approveAgent",

  "hyperliquidChain": "Mainnet" (on testnet use "Testnet" instead),
  "signatureChainId": the id of the chain used when signing in hexadecimal format; e.g. "0xa4b1" for Arbitrum,

  "agentAddress": address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000,

"agentName": Optional name for the API wallet. An account can have 1 unnamed approved wallet and up to 3 named ones. And additional 2 named agents are allowed per subaccount,

  "nonce": current timestamp in milliseconds as a Number, must match nonce in outer request body

}

nonce*

number

Recommended to use the current timestamp in milliseconds

signature*

Object

Response

200
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Approve a builder fee
POST https://api.hyperliquid.xyz/exchange

Approve a maximum fee rate for a builder.

Headers

Name
Value
Content-Type*

application/json

Body

Name
Type
Description
action*

Object

{
  "type": "approveBuilderFee",

  "hyperliquidChain": "Mainnet" (on testnet use "Testnet" instead),
  "signatureChainId": the id of the chain used when signing in hexadecimal format; e.g. "0xa4b1" for Arbitrum,

  "maxFeeRate": the maximum allowed builder fee rate as a percent string; e.g. "0.001%",

  "builder": address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000,

  "nonce": current timestamp in milliseconds as a Number, must match nonce in outer request body

}

nonce*

number

Recommended to use the current timestamp in milliseconds

signature*

Object

Response

200
Copy
{'status': 'ok', 'response': {'type': 'default'}}
Place a TWAP order
POST https://api.hyperliquid.xyz/exchange

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "twapOrder",
  "twap": {

    "a": Number,

    "b": Boolean,

    "s": String,

    "r": Boolean,

    "m": Number,

    "t": Boolean

  }

  }

Meaning of keys:
a is asset
b is isBuy
s is size
r is reduceOnly

m is minutes
t is randomize

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

vaultAddress

String

If trading on behalf of a vault or subaccount, its Onchain address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

expiresAfter

Number

Timestamp in milliseconds

200: OK Successful Response
200: OK Error Response
Copy
{
   "status":"ok",
   "response":{
      "type":"twapOrder",
      "data":{
         "status": {
            "running":{
               "twapId":77738308
            }
         }
      }
   }
}
Cancel a TWAP order
POST https://api.hyperliquid.xyz/exchange

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "twapCancel",

   "a": Number,

   "t": Number

}

Meaning of keys:
a is asset
t is twap_id

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

vaultAddress

String

If trading on behalf of a vault or subaccount, its address in 42-character hexadecimal format; e.g. 0x0000000000000000000000000000000000000000

expiresAfter

Number

Timestamp in milliseconds

200: OK Successful Response
200: OK Error Response
Copy
{
   "status":"ok",
   "response":{
      "type":"twapCancel",
      "data":{
         "status": "success"
      }
   }
}
Reserve Additional Actions
POST https://api.hyperliquid.xyz/exchange 

Instead of trading to increase the address based rate limits, this action allows reserving additional actions for 0.0005 USDC per request

Headers
Name
Type
Description
Content-Type*

String

"application/json"

Request Body
Name
Type
Description
action*

Object

{

  "type": "reserveRequestWeight",

   "weight": Number

}

nonce*

Number

Recommended to use the current timestamp in milliseconds

signature*

Object

expiresAfter

Number

Timestamp in milliseconds

200: OK Successful Response
Copy
{'status': 'ok', 'response': {'type': 'default'}}







For developers
API
Websocket
WebSocket endpoints are available for real-time data streaming and as an alternative to HTTP request sending on the Hyperliquid exchange. The WebSocket URLs by network are:

Mainnet: wss://api.hyperliquid.xyz/ws 

Testnet: wss://api.hyperliquid-testnet.xyz/ws.

Connecting
To connect to the WebSocket API, you must establish a WebSocket connection to the respective URL based on your desired network. Once connected, you can start sending subscription messages to receive real-time data updates.

Example from command line:

Copy
$ wscat -c  wss://api.hyperliquid.xyz/ws
Connected (press CTRL+C to quit)
>  { "method": "subscribe", "subscription": { "type": "trades", "coin": "SOL" } }
< {"channel":"subscriptionResponse","data":{"method":"subscribe","subscription":{"type":"trades","coin":"SOL"}}}
Note: this doc uses Typescript for defining many of the message types. If you prefer to use Python, you can check out the equivalent types in the python SDK here and example connection code here.


For developers
API
Websocket
Subscriptions
This page describes subscribing to data streams using the WebSocket API.

Subscription messages
To subscribe to specific data feeds, you need to send a subscription message. The subscription message format is as follows:

Copy
{
  "method": "subscribe",
  "subscription": { ... }
}
The subscription ack provides a snapshot of previous data for time series data (e.g. user fills). These snapshot messages are tagged with isSnapshot: true and can be ignored if the previous messages were already processed.

The subscription object contains the details of the specific feed you want to subscribe to. Choose from the following subscription types and provide the corresponding properties:

allMids:

Subscription message: { "type": "allMids", "dex": "<dex>" }

Data format: AllMids 

The dex field represents the perp dex to source mids from.

Note that the dex field is optional. If not provided, then the first perp dex is used. Spot mids are only included with the first perp dex.

notification:

Subscription message: { "type": "notification", "user": "<address>" }

Data format: Notification

webData2

Subscription message: { "type": "webData2", "user": "<address>" }

Data format: WebData2

candle:

Subscription message: { "type": "candle", "coin": "<coin_symbol>", "interval": "<candle_interval>" }

Data format: Candle[]

l2Book:

Subscription message: { "type": "l2Book", "coin": "<coin_symbol>" }

Optional parameters: nSigFigs: int, mantissa: int

Data format: WsBook

trades:

Subscription message: { "type": "trades", "coin": "<coin_symbol>" }

Data format: WsTrade[]

orderUpdates:

Subscription message: { "type": "orderUpdates", "user": "<address>" }

Data format: WsOrder[]

userEvents: 

Subscription message: { "type": "userEvents", "user": "<address>" }

Data format: WsUserEvent

userFills: 

Subscription message: { "type": "userFills", "user": "<address>" }

Optional parameter:  aggregateByTime: bool 

Data format: WsUserFills

userFundings: 

Subscription message: { "type": "userFundings", "user": "<address>" }

Data format: WsUserFundings

userNonFundingLedgerUpdates: 

Subscription message: { "type": "userNonFundingLedgerUpdates", "user": "<address>" }

Data format: WsUserNonFundingLedgerUpdates

activeAssetCtx: 

Subscription message: { "type": "activeAssetCtx", "coin": "coin_symbol>" }

Data format: WsActiveAssetCtx or WsActiveSpotAssetCtx 

activeAssetData: (only supports Perps)

Subscription message: { "type": "activeAssetData", "user": "<address>", "coin": "coin_symbol>" }

Data format: WsActiveAssetData

userTwapSliceFills: 

Subscription message: { "type": "userTwapSliceFills", "user": "<address>" }

Data format: WsUserTwapSliceFills

userTwapHistory: 

Subscription message: { "type": "userTwapHistory", "user": "<address>" }

Data format: WsUserTwapHistory

bbo :

Subscription message: { "type": "bbo", "coin": "<coin>" }

Data format: WsBbo

Data formats
The server will respond to successful subscriptions with a message containing the channel property set to "subscriptionResponse", along with the data field providing the original subscription. The server will then start sending messages with the channel property set to the corresponding subscription type e.g. "allMids" and the data field providing the subscribed data.

The data field format depends on the subscription type:

AllMids: All mid prices.

Format: AllMids { mids: Record<string, string> }

Notification: A notification message.

Format: Notification { notification: string }

WebData2: Aggregate information about a user, used primarily for the frontend.

Format: WebData2

WsTrade[]: An array of trade updates.

Format: WsTrade[]

WsBook: Order book snapshot updates.

Format: WsBook { coin: string; levels: [Array<WsLevel>, Array<WsLevel>]; time: number; }

WsOrder: User order updates.

Format: WsOrder[]

WsUserEvent: User events that are not order updates

Format: WsUserEvent { "fills": [WsFill] | "funding": WsUserFunding | "liquidation": WsLiquidation | "nonUserCancel": [WsNonUserCancel] }

WsUserFills : Fills snapshot followed by streaming fills

WsUserFundings : Funding payments snapshot followed by funding payments on the hour

WsUserNonFundingLedgerUpdates: Ledger updates not including funding payments: withdrawals, deposits, transfers, and liquidations

WsBbo : Bbo updates that are sent only if the bbo changes on a block

For the streaming user endpoints such as WsUserFills,WsUserFundings the first message has isSnapshot: true and the following streaming updates have isSnapshot: false. 

Data type definitions
Here are the definitions of the data types used in the WebSocket API:

Copy
interface WsTrade {
  coin: string;
  side: string;
  px: string;
  sz: string;
  hash: string;
  time: number;
  // tid is 50-bit hash of (buyer_oid, seller_oid). 
  // For a globally unique trade id, use (block_time, coin, tid)
  tid: number;  
  users: [string, string] // [buyer, seller]
}

// Snapshot feed, pushed on each block that is at least 0.5 since last push
interface WsBook {
  coin: string;
  levels: [Array<WsLevel>, Array<WsLevel>];
  time: number;
}

interface WsBbo {
  coin: string;
  time: number;
  bbo: [WsLevel | null, WsLevel | null];
}

interface WsLevel {
  px: string; // price
  sz: string; // size
  n: number; // number of orders
}

interface Notification {
  notification: string;
}

interface AllMids {
  mids: Record<string, string>;
}

interface Candle {
  t: number; // open millis
  T: number; // close millis
  s: string; // coin
  i: string; // interval
  o: number; // open price
  c: number; // close price
  h: number; // high price
  l: number; // low price
  v: number; // volume (base unit)
  n: number; // number of trades
}

type WsUserEvent = {"fills": WsFill[]} | {"funding": WsUserFunding} | {"liquidation": WsLiquidation} | {"nonUserCancel" :WsNonUserCancel[]};

interface WsUserFills {
  isSnapshot?: boolean;
  user: string;
  fills: Array<WsFill>;
}

interface WsFill {
  coin: string;
  px: string; // price
  sz: string; // size
  side: string;
  time: number;
  startPosition: string;
  dir: string; // used for frontend display
  closedPnl: string;
  hash: string; // L1 transaction hash
  oid: number; // order id
  crossed: boolean; // whether order crossed the spread (was taker)
  fee: string; // negative means rebate
  tid: number; // unique trade id
  liquidation?: FillLiquidation;
  feeToken: string; // the token the fee was paid in
  builderFee?: string; // amount paid to builder, also included in fee
}

interface FillLiquidation {
  liquidatedUser?: string;
  markPx: number;
  method: "market" | "backstop";
}

interface WsUserFunding {
  time: number;
  coin: string;
  usdc: string;
  szi: string;
  fundingRate: string;
}

interface WsLiquidation {
  lid: number;
  liquidator: string;
  liquidated_user: string;
  liquidated_ntl_pos: string;
  liquidated_account_value: string;
}

interface WsNonUserCancel {
  coin: String;
  oid: number;
}

interface WsOrder {
  order: WsBasicOrder;
  status: string; // Possible values: open, filled, canceled, triggered, rejected, marginCanceled
  statusTimestamp: number;
}

interface WsBasicOrder {
  coin: string;
  side: string;
  limitPx: string;
  sz: string;
  oid: number;
  timestamp: number;
  origSz: string;
  cloid: string | undefined;
}

interface WsActiveAssetCtx {
  coin: string;
  ctx: PerpsAssetCtx;
}

interface WsActiveSpotAssetCtx {
  coin: string;
  ctx: SpotAssetCtx;
}

type SharedAssetCtx = {
  dayNtlVlm: number;
  prevDayPx: number;
  markPx: number;
  midPx?: number;
};

type PerpsAssetCtx = SharedAssetCtx & {
  funding: number;
  openInterest: number;
  oraclePx: number;
};

type SpotAssetCtx = SharedAssetCtx & {
  circulatingSupply: number;
};

interface WsActiveAssetData {
  user: string;
  coin: string;
  leverage: Leverage;
  maxTradeSzs: [number, number];
  availableToTrade: [number, number];
}

interface WsTwapSliceFill {
  fill: WsFill;
  twapId: number;
}

interface WsUserTwapSliceFills {
  isSnapshot?: boolean;
  user: string;
  twapSliceFills: Array<WsTwapSliceFill>;
}

interface TwapState {
  coin: string;
  user: string;
  side: string;
  sz: number;
  executedSz: number;
  executedNtl: number;
  minutes: number;
  reduceOnly: boolean;
  randomize: boolean;
  timestamp: number;
}

type TwapStatus = "activated" | "terminated" | "finished" | "error";
interface WsTwapHistory {
  state: TwapState;
  status: {
    status: TwapStatus;
    description: string;
  };
  time: number;
}

interface WsUserTwapHistory {
  isSnapshot?: boolean;
  user: string;
  history: Array<WsTwapHistory>;
}
Please note that the above data types are in TypeScript format, and their usage corresponds to the respective subscription types.

Examples
Here are a few examples of subscribing to different feeds using the subscription messages:

Subscribe to all mid prices:

Copy
{ "method": "subscribe", "subscription": { "type": "allMids" } }
Subscribe to notifications for a specific user:

Copy
{ "method": "subscribe", "subscription": { "type": "notification", "user": "<address>" } }
Subscribe to web data for a specific user:

Copy
{ "method": "subscribe", "subscription": { "type": "webData", "user": "<address>" } }
Subscribe to candle updates for a specific coin and interval:

Copy
{ "method": "subscribe", "subscription": { "type": "candle", "coin": "<coin_symbol>", "interval": "<candle_interval>" } }
Subscribe to order book updates for a specific coin:

Copy
{ "method": "subscribe", "subscription": { "type": "l2Book", "coin": "<coin_symbol>" } }
Subscribe to trades for a specific coin:

Copy
{ "method": "subscribe", "subscription": { "type": "trades", "coin": "<coin_symbol>" } }
Unsubscribing from WebSocket feeds
To unsubscribe from a specific data feed on the Hyperliquid WebSocket API, you need to send an unsubscribe message with the following format:

Copy
{
  "method": "unsubscribe",
  "subscription": { ... }
}
The subscription object should match the original subscription message that was sent when subscribing to the feed. This allows the server to identify the specific feed you want to unsubscribe from. By sending this unsubscribe message, you inform the server to stop sending further updates for the specified feed.

Please note that unsubscribing from a specific feed does not affect other subscriptions you may have active at that time. To unsubscribe from multiple feeds, you can send multiple unsubscribe messages, each with the appropriate subscription details.

Previous
Websocket






For developers
API
Websocket
Post requests
This page describes posting requests using the WebSocket API.

Request format
The WebSocket API supports posting requests that you can normally post through the HTTP API. These requests are either info requests or signed actions. For examples of info request payloads, please refer to the Info endpoint section. For examples of signed action payloads, please refer to the Exchange endpoint section.

To send such a payload for either type via the WebSocket API, you must wrap it as such:

Copy
{
  "method": "post",
  "id": <number>,
  "request": {
    "type": "info" | "action",
    "payload": { ... }
  }
}
Note: The method and id fields are mandatory. It is recommended that you use a unique id for every post request you send in order to track outstanding requests through the channel.

Note: explorer requests are not supported via WebSocket.

Response format
The server will respond to post requests with either a success or an error. For errors, a String is returned mirroring the HTTP status code and description that would have been returned if the request were sent through HTTP.

Copy
{
  "channel": "post",
  "data": {
    "id": <number>,
    "response": {
      "type": "info" | "action" | "error",
      "payload": { ... }
    }
  }
}
Examples
Here are a few examples of subscribing to different feeds using the subscription messages:

Sending an L2Book info request:

Copy
{
  "method": "post",
  "id": 123,
  "request": {
    "type": "info",
    "payload": {
      "type": "l2Book",
      "coin": "ETH",
      "nSigFigs": 5,
      "mantissa": null
    }
  }
}
Sample response:

Copy
{
  "channel": "post",
  "data": {
    "id": <number>,
    "response": {
      "type": "info",
      "payload": {
        "type": "l2Book",
        "data": {
          "coin": "ETH",
          "time": <number>,
          "levels": [
            [{"px":"3007.1","sz":"2.7954","n":1}],
            [{"px":"3040.1","sz":"3.9499","n":1}]
          ]
        }
      }
    }
  }
}
Sending an order signed action request:

Copy
{
  "method": "post",
  "id": 256,
  "request": {
    "type": "action",
    "payload": {
      "action": {
        "type": "order",
        "orders": [{"a": 4, "b": true, "p": "1100", "s": "0.2", "r": false, "t": {"limit": {"tif": "Gtc"}}}],
        "grouping": "na"
      },
      "nonce": 1713825891591,
      "signature": {
        "r": "...",
        "s": "...",
        "v": "..."
      },
      "vaultAddress": "0x12...3"
    }
  }
}
Sample response:

Copy
{
  "channel": "post",
  "data": {
    "id": 256,
    "response": {
      "type":"action",
      "payload": {
        "status": "ok",
        "response": {
          "type": "order",
          "data": {
            "statuses": [
              {
                "resting": {
                  "oid": 88383,
                }
              }
            ]
          }
        }
      }
    }
  }
}



For developers
API
Websocket
Timeouts and heartbeats
This page describes the measures to keep WebSocket connections alive.

The server will close any connection if it hasn't sent a message to it in the last 60 seconds. If you are subscribing to a channel that doesn't receive messages every 60 seconds, you can send heartbeat messages to keep your connection alive. The format for these messages are:

Copy
{ "method": "ping" }
The server will respond with:

Copy
{ "channel": "pong" }




For developers
API
Error responses
Order and cancel errors are usually returned as a vector with same length as the batched request.

Below is a list of possible batched error responses:

Error source
Error type
Error string
Order

Tick

Price must be divisible by tick size.

Order

MinTradeNtl

Order must have minimum value of $10

Order

PerpMargin

Insufficient margin to place order.

Order

ReduceOnly

Reduce only order would increase position.

Order

BadAloPx

Post only order would have immediately matched, bbo was {bbo}.

Order

IocCancel

Order could not immediately match against any resting orders.

Order

BadTriggerPx

Invalid TP/SL price.

Order

MarketOrderNoLiquidity

No liquidity available for market order.

Order

PositionIncreaseAtOpenInterestCap

Order would increase open interest while open interest is capped

Order

PositionFlipAtOpenInterestCap

Order would increase open interest while open interest is capped

Order

TooAggressiveAtOpenInterestCap

Order rejected due to price more aggressive than oracle while at open interest cap

Order

OpenInterestIncrease

Order would increase open interest too quickly

Order

InsufficientSpotBalance

(Spot-only) Order has insufficient spot balance to trade

Order

Oracle

Order price too far from oracle

Order

PerpMaxPosition

Order would cause position to exceed margin tier limit at current leverage

Cancel

MissingOrder

Order was never placed, already canceled, or filled.

Important: Some errors are a deterministic function of the payload itself, and these are instead returned earlier as part of pre-validation. In this case only one error is returned for the entire payload, as some of these errors do not apply to a specific order or cancel.

Examples include: empty batch of orders, non-reduce-only TP/SL orders, and some forms of tick size validation. 

For API users that use batching, it's recommended to handle the case where a single error is returned for a batch of multiple orders. In this case, the response could be duplicated ntimes before being sent to the callback function, as the whole batch was rejected for this same reason.

For API users that use historical orders, a list of all the cancel / reject historical order statuses can be found below:

Historical Order Status
Reason
marginCanceled

Canceled due to insufficient margin

vaultWithdrawalCanceled

Canceled due to vault withdrawal

openInterestCapCanceled

Canceled due to open interest cap

selfTradeCanceled

Canceled due to self-trade prevention

reduceOnlyCanceled

Canceled due to reduce only

siblingFilledCanceled

Canceled due to TP/SL child sibling fill

delistedCanceled

Canceled due to asset delisting

liquidatedCanceled

Canceled due to liquidation

scheduledCancel

Canceled due to scheduled cancel action

internalCancel

Canceled due to internal error

perpMaxPositionCanceled

Canceled due to exceeding margin tier limit at current leverage

tickRejected

Rejected due to invalid tick price

minTradeNtlRejected

Rejected due to order notional below minimum

perpMarginRejected

Rejected due to insufficient margin

reduceOnlyRejected

Rejected due to reduce only

badAloPxRejected

Rejected due to post-only immediate match

iocCancelRejected

Rejected due to IOC not able to match

badTriggerPxRejected

Rejected due to invalid TP/SL price

marketOrderNoLiquidityRejected

Rejected due to lack of liquidity for market order

positionIncreaseAtOpenInterestCapRejected

Rejected due to open interest cap

positionFlipAtOpenInterestCapRejected

Rejected due to open interest cap

tooAggressiveAtOpenInterestCapRejected

Rejected due to price too aggressive at open interest cap

openInterestIncreaseRejected

Rejected due to open interest cap

insufficientSpotBalanceRejected

Rejected due to insufficient spot balance

oracleRejected

Rejected due to price too far from oracle

perpMaxPositionRejected

Rejected due to exceeding margin tier limit at current leverage



For developers
API
Signing
It is recommended to use an existing SDK instead of manually generating signatures. There are many potential ways in which signatures can be wrong. An incorrect signature results in recovering a different signer based on the signature and payload and results in one of the following errors:
"L1 error: User or API Wallet 0x0123... does not exist."
Must deposit before performing actions. User: 0x123...
where the returned address does not match the public address of the wallet you are signing with. The returned address also changes for different inputs.
An incorrect signature does not indicate why it is incorrect which makes debugging more challenging. To debug this it is recommended to read through the Python SDK carefully and make sure the implementation matches exactly. If that doesn't work, add logging to find where the output diverges.

Some common errors:
1. Not realizing that there are two signing schemes (the Python SDK methods are sign_l1_action vs sign_user_signed_action).
2. Not realizing that the order of fields matter for msgpack.
3. Issues with trailing zeroes on numbers.
4. Issues with upper case characters in address fields. It is recommended to lowercase any address before signing and sending. Sometimes the field is parsed as bytes, causing it to be lowercased automatically across the network.
5. Believing that the signature must be correct because calling recover signer locally results in the correct address. The payload for recover signer is constructed based on the action and does not necessarily match.

Previous
Error responses
Next


For developers
API
Rate limits
The following rate limits apply per IP address:

REST requests share an aggregated weight limit of 1200 per minute. 

All documented exchange API requests have a weight of 1 + floor(batch_length / 40). For example, unbatched actions have weight 1 and a batched order request of length 79 has weight 2. Here, batch_lengthis the length of the array in the action, e.g. the number of orders in a batched order action.

The following info requests have weight 2: l2Book, allMids, clearinghouseState, orderStatus, spotClearinghouseState, exchangeStatus.

The following info requests have weight 60: userRole .

All other documented info requests have weight 20.

All explorer API requests have a weight of 40.

Maximum of 100 websocket connections

Maximum of 1000 websocket subscriptions

Maximum of 10 unique users across user-specific websocket subscriptions

Maximum of 2000 messages sent to Hyperliquid per minute across all websocket connections

Maximum of 100 simultaneous inflight post messages across all websocket connections

Use websockets for lowest latency realtime data. See the python SDK for a full-featured example.

Address-based rate limits
The rate limiting logic will allow 1 request per 1 USDC traded cumulatively since address inception.

Using an order value of 100 USDC, this only requires a fill rate of 1%.

Each address starts with an initial buffer of 10000 requests. When rate limited, an address will still be allowed one request every 10 seconds.

Cancels have cumulative limit min(limit + 100000, limit * 2) where limit is the default limit for other actions. This way, hitting the address-based rate limit will still allow open orders to be canceled. 

Note that this rate limit only applies to actions, not info requests. 

Batched Requests
A batched request with n orders (or cancels) is treated as one request for IP based rate limiting, but as n requests for address-based rate limiting.  


For developers
API
Bridge2
General Information
The bridge between Hyperliquid and Arbitrum: https://arbiscan.io/address/0x2df1c51e09aecf9cacb7bc98cb1742757f163df7

The bridge code: https://github.com/hyperliquid-dex/contracts/blob/master/Bridge2.sol

Deposit
The deposit flow for the bridge is simple. The user sends native USDC to the bridge, and it is credited to the account that sent it in less than 1 minute. The minimum deposit amount is 5 USDC. If you send an amount less than this, it will not be credited and be lost forever. 

Withdraw
The withdrawal flow requires a user wallet signature on Hyperliquid only, and no Arbitrum transaction. The withdrawal from Arbitrum is handled entirely by validators, and the funds arrive in the user wallet in 3-4 minutes. This payload for signTypedData is

Copy
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[serde(deny_unknown_fields)]
pub(crate) struct WithdrawAction3 {
    pub(crate) signature_chain_id: U256,
    pub(crate) hyperliquid_chain: Chain,
    pub(crate) destination: String,
    pub(crate) amount: String,
    pub(crate) time: u64,
}

impl Eip712 for WithdrawAction3 {
    type Error = Eip712Error;

    fn domain(&self) -> StdResult<EIP712Domain, Self::Error> {
        Ok(eip_712_domain(self.signature_chain_id))
    }

    fn type_hash() -> StdResult<[u8; 32], Self::Error> {
        Ok(eip712::make_type_hash(
            format!("{HYPERLIQUID_EIP_PREFIX}Withdraw"),
            &[
                ("hyperliquidChain".to_string(), ParamType::String),
                ("destination".to_string(), ParamType::String),
                ("amount".to_string(), ParamType::String),
                ("time".to_string(), ParamType::Uint(64)),
            ],
        ))
    }

    fn struct_hash(&self) -> StdResult<[u8; 32], Self::Error> {
        let Self { signature_chain_id: _, hyperliquid_chain, destination, amount, time } = self;
        let items = vec![
            ethers::abi::Token::Uint(Self::type_hash()?.into()),
            encode_eip712_type(hyperliquid_chain.to_string().into_token()),
            encode_eip712_type(destination.clone().into_token()),
            encode_eip712_type(amount.clone().into_token()),
            encode_eip712_type(time.into_token()),
        ];
        Ok(keccak256(encode(&items)))
    }
}
Example signed Hyperliquid action:

Copy
{
    "action": {
        "type": "withdraw3",
        "signatureChainId": "0xa4b1",
        "hyperliquidChain": "Mainnet" or "Testnet" 
        "destination": "0x000....0",
        "amount": "12.3",
        "time": 1698693262
    },
    "nonce": 1698693262 // IMPORTANT: this must match "time",
    "signature": {"r": ..., "s": ..., "v": ... } // signedTypedData output based on Eip712 implementation above. See python sdk for equivalent python code
}
Deposit with permit
The bridge supports depositing on behalf of another user via the batchedDepositWithPermitfunction. Example code for how the user can sign the PermitPayload

Copy
const payload: PermitPayload = {
  owner, // The address of the user with funds they want to deposit
  spender, // The address of the bridge 0x2df1c51e09aecf9cacb7bc98cb1742757f163df7 on mainnet and 0x08cfc1B6b2dCF36A1480b99353A354AA8AC56f89 on testnet
  value,
  nonce,
  deadline,
};

const isMainnet = true;

const domain = {
  name: isMainnet ? "USD Coin" : "USDC2",
  version: isMainnet ? "2" : "1",
  chainId: isMainnet ? 42161 : 421614,
  verifyingContract: isMainnet ? "0xaf88d065e77c8cC2239327C5EDb3A432268e5831" : "0x1baAbB04529D43a73232B713C0FE471f7c7334d5",
};

const permitTypes = {
  Permit: [
    { name: "owner", type: "address" },
    { name: "spender", type: "address" },
    { name: "value", type: "uint256" },
    { name: "nonce", type: "uint256" },
    { name: "deadline", type: "uint256" },
  ],
};

const dataToSign = {
  domain,
  types: permitTypes,
  primaryType: "Permit",
  message: payload,
} as const;

const data = await walletClient.signTypedData(dataToSign);
const signature = splitSig(data);




For developers
API
Deploying HIP-1 and HIP-2 assets
The API for deploying HIP-1 and HIP-2 assets is a five-step process which involves sending the first 5 variants (the last one is optional) of the enum in the order below.

Copy
type SpotDeployAction = 
  | {
      type: "spotDeploy";
      registerToken2: RegisterToken2;
    }
  | {
      type: "spotDeploy";
      userGenesis: UserGenesis;
    }
  | {
      type: "spotDeploy";
      genesis: Genesis;
    }
  | {
      type: "spotDeploy";
      registerSpot: RegisterSpot;
    }
  | {
      type: "spotDeploy";
      registerHyperliquidity: RegisterHyperliquidity;
    }
  | {
      type: "spotDeploy";
      setDeployerTradingFeeShare: SetDeployerTradingFeeShare;
    };

type RegisterToken2 = {
  spec: TokenSpec;
  maxGas: number;
  fullName?: string;
}

type TokenSpec = {
  name: string,
  szDecimals: number,
  weiDecimals: number,
}

/**
 * UserGenesis can be called multiple times
 * @param token - The token involved in the genesis.
 * @param userAndWei - A list of tuples of user address and genesis amount (wei).
 * @param existingTokenAndWei - A list of tuples of existing token and total genesis amount for holders of that token (wei).
 * @param blacklistUsers - A list of tuples of users and blacklist status (True if blacklist, False to remove existing blacklisted user).
 */
type UserGenesis = {
  token: number;
  userAndWei: Array<[string, string]>;
  existingTokenAndWei: Array<[number, string]>;
  blacklistUsers?: Array<[string, boolean]>;
}

/**
 * Genesis denotes the initial creation of a token with a maximum supply.
 * @param maxSupply - Checksum ensureing all calls to UserGenesis succeeded
 * @param noHyperliquidity - Set hyperliquidity balance to 0.
 */
type Genesis = {
  token: number;
  maxSupply: string;
  noHyperliquidity?: boolean;
}

/**
 * @param tokens - [base index, quote index]
 */
type RegisterSpot = {
  tokens: [number, number];
}

/**
 * @param spot - The spot index (different from base token index)
 * @param startPx - The starting price.
 * @param orderSz - The size of each order (float, not wei)
 * @param nOrders - The number of orders. If "noHyperliquidity" was set to True, then this must be 0.
 * @param nSeededLevels - The number of levels the deployer wishes to seed with usdc instead of tokens.
 */
type RegisterHyperliquidity = {
  spot: number;
  startPx: string;
  orderSz: string;
  nOrders: number;
  nSeededLevels?: number;
}

/**
 * This is an optional action that can be performed at any time after 
 * RegisterToken2. While the fee share defaults to 100%, this action
 * can be resent multiple times as long as the fee share is not increasing.
 * @param token - The token
 * @param share - The deployer trading fee share. Range: ["0%", "100%"]. Examples: "0.012%", "99.4%"
 */
type SetDeployerTradingFeeShare {
  token: number;
  share: string;
}



For developers
API
Deploying HIP-3 assets
The API for deploying and operating builder-deployed perpetual dexs involves the following L1 action:

Copy
type PerpDeployAction =
  | {
      type: "perpDeploy";
      registerAsset: RegisterAsset;
    }
  | {
      type: "perpDeploy";
      setOracle: SetOracle;
    };
    
/**
 * RegisterAsset can be called to initialize a new dex and register an asset at the same time.
 * If schema is not provided, then RegisterAsset can be called multiple times to register additional assets
 * for the provided dex.
 * @param maxGas - Max gas in native token wei. If not provided, then uses current deploy auction price.
 * @param assetRequest - Contains new asset listing parameters. See RegisterAssetRequest below for details.
 * @param dex - Name of the perp dex (<= 6 characters)
 * @param schema - Contains new perp dex parameters. See PerpDexSchemaInput below for details.
 */
type RegisterAsset = {
  maxGas?: number;
  assetRequest: RegisterAssetRequest;
  dex: string;
  schema?: PerpDexSchemaInput;
}

/**
 * SetOracle can be called multiple times
 * @param dex - Name of the perp dex (<= 6 characters)
 * @param oraclePxs - A list (sorted by key) of asset and oracle prices.
 * @param markPxs - A list (sorted by key) of asset and mark prices.
 */
type SetOracle {
  dex: string;
  oraclePxs: Array<[string, string]>;
  markPxs: Array<[string, string]>;
}

type RegisterAssetReqeust {
  coin: string;
  szDecimals: number;
  oraclePx: string;
  marginTableId: number;
  onlyIsolated: boolean;
}

/**
 * @param fullName - Full name of the perp dex
 * @param collateralToken - Collateral token index
 * @param oracleUpdater - User to update oracles. If not provided, then deployer is assumed to be oracle updater.
 */
type PerpDexSchemaInput {
  fullName: string;
  collateralToken: int;
  oracleUpdater?: string;
}
See https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-information-about-the-perp-deploy-auction for how to query for the perp deploy auction status.











For developers
API
Deploying HIP-3 assets
The API for deploying and operating builder-deployed perpetual dexs involves the following L1 action:

Copy
type PerpDeployAction =
  | {
      type: "perpDeploy";
      registerAsset: RegisterAsset;
    }
  | {
      type: "perpDeploy";
      setOracle: SetOracle;
    };
    
/**
 * RegisterAsset can be called to initialize a new dex and register an asset at the same time.
 * If schema is not provided, then RegisterAsset can be called multiple times to register additional assets
 * for the provided dex.
 * @param maxGas - Max gas in native token wei. If not provided, then uses current deploy auction price.
 * @param assetRequest - Contains new asset listing parameters. See RegisterAssetRequest below for details.
 * @param dex - Name of the perp dex (<= 6 characters)
 * @param schema - Contains new perp dex parameters. See PerpDexSchemaInput below for details.
 */
type RegisterAsset = {
  maxGas?: number;
  assetRequest: RegisterAssetRequest;
  dex: string;
  schema?: PerpDexSchemaInput;
}

/**
 * SetOracle can be called multiple times
 * @param dex - Name of the perp dex (<= 6 characters)
 * @param oraclePxs - A list (sorted by key) of asset and oracle prices.
 * @param markPxs - A list (sorted by key) of asset and mark prices.
 */
type SetOracle {
  dex: string;
  oraclePxs: Array<[string, string]>;
  markPxs: Array<[string, string]>;
}

type RegisterAssetReqeust {
  coin: string;
  szDecimals: number;
  oraclePx: string;
  marginTableId: number;
  onlyIsolated: boolean;
}

/**
 * @param fullName - Full name of the perp dex
 * @param collateralToken - Collateral token index
 * @param oracleUpdater - User to update oracles. If not provided, then deployer is assumed to be oracle updater.
 */
type PerpDexSchemaInput {
  fullName: string;
  collateralToken: int;
  oracleUpdater?: string;
}
See https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-information-about-the-perp-deploy-auction for how to query for the perp deploy auction status.




For developers
HyperEVM
The HyperEVM consists of EVM blocks built as part of Hyperliquid's execution, inheriting all security from HyperBFT consensus. HYPE is the native gas token on the HyperEVM. To move HYPE from HyperCore to HyperEVM, send HYPE to 0x2222222222222222222222222222222222222222. See the instructions in Native Transfers for more details on how this works.

Note that there are currently no official frontend components of the EVM. Users can build their own frontends or port over existing EVM applications. All interaction with the EVM happens through the JSON-RPC. For example, users can add the chain to their wallets by entering the RPC URL and chain ID. There is currently no websocket JSON-RPC support for the RPC at rpc.hyperliquid.xyz/evmbut other RPC implementations may support it.

The HyperEVM uses the Cancun hardfork without blobs. In particular, EIP-1559 is enabled on the HyperEVM. Base fees are burned as usual, implemented in the standard way where the burned fees are removed from the total EVM supply. Unlike most other EVM chains, priority fees are also burned because the HyperEVM uses HyperBFT consensus. The burned priority fees are sent to the zero address's EVM balance. 

On both mainnet and testnet, HYPE on the HyperEVM has 18 decimals. A few differences between testnet and mainnet HyperEVM are highlighted below:

Mainnet
Chain ID: 999

JSON-RPC endpoint: https://rpc.hyperliquid.xyz/evm for mainnet 

Testnet
Chain ID: 998 

JSON-RPC endpoint: https://rpc.hyperliquid-testnet.xyz/evm



For developers
HyperEVM
Dual-block architecture
The total HyperEVM throughput is split between small blocks produced at a fast rate and large blocks produced at a slower rate. 

The primary motivation behind the dual-block architecture is to decouple block speed and block size when allocating throughput improvements. Users want faster blocks for lower time to confirmation. Builders want larger blocks to include larger transactions such as more complex contract deployments. Instead of a forced tradeoff, the dual-block system will allow simultaneous improvement along both axes. 

The HyperEVM "mempool" is still onchain state with respect to the umbrella L1 execution, but is split into two independent mempools that source transactions for the two block types. The two block types are interleaved with a unique increasing sequence of EVM block numbers. The onchain mempool implementation accepts only the next 8 nonces for each address. Transactions older than 1 day old in the mempool are pruned. 

The initial configuration is set conservatively, and throughput is expected to increase over successive technical upgrades. Fast block duration is set to 1 seconds with a 2M gas limit. Slow block duration is set to 1 minute with a 30M gas limit. 

More precisely, in the definitions above, block duration of x means that the first L1 block for each value   of l1_block_time % x produces an EVM block. 

Developers can deploy larger contracts as follows:

Submit action {"type": "evmUserModify", "usingBigBlocks": true} to direct HyperEVM transactions to big blocks instead of small blocks. Note that this user state flag is set on the HyperCore user level, and must be unset again to target small blocks. Like any action, this requires an existing Core user to send. Like any EOA, the deployer address can be converted to a Core user by receiving a Core asset such as USDC.

Optionally use the JSON-RPC method bigBlockGasPrice in place of gasPrice to estimate base gas fee on the next big block.





For developers
HyperEVM
Raw HyperEVM block data
Builders running a non-validating node can index the HyperEVM using data written to ~/hl/data/evm_block_and_receipts . This data is written after committed blocks are verified by the node, and therefore has no additional trust assumptions compared to running the EVM RPC directly from the node itself.

Builders that wish to index the HyperEVM without running a node can use the S3 bucket: aws s3 ls s3://hl-mainnet-evm-blocks/ --request-payer requester. 

There is a similar bucket s3://hl-testnet-evm-blocks/ for testnet.

Builders interested in robustness can merge the two data sources, relying primarily on local data and falling back to S3 data.

Some potential applications include a JSON-RPC server with custom rate limits, a HyperEVM block explorer, or other indexed services and tooling for builders.

While the data is public for anyone to use, the requester must pay for data transfer costs. The filenames are predictably indexed by EVM block number, e.g. s3://hl-mainnet-evm-blocks/0/6000/6123.rmp.lz4. An indexer can copy block data from S3 on new HyperEVM blocks. The files are stored in MessagePack format and then compressed using LZ4.

Note that testnet starts with directory s3://hl-testnet-evm-blocks/18000000and the earlier testnet RPC blocks were not backfilled.

An example can be found in the Python SDK: https://github.com/hyperliquid-dex/hyperliquid-python-sdk/blob/master/examples/evm_block_indexer.py




For developers
HyperEVM
Interacting with HyperCore
Read precompiles
The testnet EVM provides read precompiles that allows querying HyperCore information. The precompile addresses start at  0x0000000000000000000000000000000000000800 and have methods for querying information such as perps positions, spot balances, vault equity, staking delegations, oracle prices, and the L1 block number.

The values are guaranteed to match the latest HyperCore state at the time the EVM block is constructed.

Attached is a Solidity file L1Read.sol describing the read precompiles. As an example, this call queries the third perp oracle price on testnet:

Copy
cast call 0x0000000000000000000000000000000000000807 0x0000000000000000000000000000000000000000000000000000000000000003 --rpc-url https://rpc.hyperliquid-testnet.xyz/evm
To convert to floating point numbers, divide the returned price by 10^(6 - szDecimals)for perps and 10^(8 - base asset szDecimals) for spot.

Precompiles called on invalid inputs such as invalid assets or vault address will return an error and consume all gas passed into the precompile call frame. Precompiles have a gas cost of 2000 + 65 * output_len.

CoreWriter contract (testnet only)
A system contract is available at 0x3333333333333333333333333333333333333333 for sending transactions from the HyperEVM to HyperCore. It burns ~25,000 gas before emitting a log to be processed by HyperCore as an action. In practice the gas usage for a basic call will be ~47000. A solidity file CoreWriter.sol for the write system contract is attached.

Action encoding details
Byte 1: Encoding version

Currently, only version 1 is supported, but enables future upgrades while maintaining backward compatibility.

Bytes 2-4: Action ID

These three bytes, when decoded as a big-endian unsigned integer, represent the unique identifier for the action.

Remaining bytes: Action encoding

The rest of the bytes constitue the action-specific data. It is always the raw ABI encoding of a sequence of Solidity types

Action ID
Action
Fields
Solidity Type
Notes
1

Limit order

(asset, isBuy, limitPx, sz, reduceOnly, encodedTif, cloid)

(uint32, bool, uint64, uint64, bool, uint8, uint128)

Tif encoding: 1 for Alo , 2 for Gtc , 3 for Ioc . Cloid encoding: 0 means no cloid, otherwise uses the number as the cloid.

2

Vault transfer

(vault, isDeposit, usd)

(address, bool, uint64)

3

Token delegate

(validator, wei, isUndelegate)

(address, uint64, bool)

4

Staking deposit

wei

uint64

5

Staking withdraw

wei

uint64

6

Spot send

(destination, token, wei)

(address, uint64, uint64)

7

USD class transfer

(ntl, toPerp)

(uint64, bool)


Happy building. Any feedback is appreciated.



For developers
HyperEVM
HyperCore <> HyperEVM transfers
Introduction
Spot assets can be sent between HyperCore and the HyperEVM. In the context of these transfers, spot assets on HyperCore are called Core spot while ones on the EVM are called EVM spot. The spot deployer can link their Core spot asset to any ERC20 contract deployed to the EVM. The Core spot asset and ERC20 token can be deployed in either order.

As the native token on HyperCore, HYPE also links to the native HyperEVM balance rather than an ERC20 contract.

System Addresses
Every token has a system address on the Core, which is the address with first byte 0x20 and the remaining bytes all zeros, except for the token index encoded in big-endian format. For example, for token index 200, the system address would be 0x20000000000000000000000000000000000000c8 .

The exception is HYPE, which has a system address of 0x2222222222222222222222222222222222222222 .

Transferring HYPE
HYPE is a special case as the native gas token on the HyperEVM. HYPE is received on the EVM side of a transfer as the native gas token instead of an ERC20 token. To transfer back to HyperCore, HYPE can be sent as a transaction value. The EVM transfer address 0x222..2 is a system contract that emits event Received(address indexed user, uint256 amount) as its payable receive() function. Here user is msg.sender, so this implementation enables both smart contracts and EOAs to transfer HYPE back to HyperCore. Note that there is a small gas cost to emitting this log on the EVM side.

Transferring between Core and EVM
Only once a token is linked, it can be converted between HyperCore and HyperEVM spot using a spotSend action (or via the frontend) and on the EVM by using an ERC20 transfer.

Transferring tokens from HyperCore to HyperEVM can be done using a spotSend action (or via the frontend) with the corresponding system address as the destination. The tokens are credited by a system transaction that calls transfer(recipient, amount) on the linked contract as the system address, where recipient is the sender of the spotSend action. 

Transferring tokens from HyperEVM to HyperCore can be done using an ERC20 transfer with the corresponding system address as the destination. The tokens are credited to the Core based on the emitted Transfer(address from, address to, uint256 value) from the linked contract.

Do not blindly assume accurate fungibility between Core and EVM spot. See Caveats for more details.

Gas costs
A transfer from HyperEVM to HyperCore costs similar gas to the equivalent transfer of the ERC20 token or HYPE to any other address on the HyperEVM that has an existing balance.

A transfer from HyperCore to HyperEVM costs 200k gas at the base gas price of the next HyperEVM block.

Linking Core and EVM Spot Assets
In order for transfers between Core spot and EVM spot to work the token's system address must have the total non-system balance on the other side. For example, to deploy an ERC20 contract for an existing Core spot asset, the system contract should have the entirety of the EVM spot supply equal to the max Core spot supply.

Once this is done the spot deployer needs to send a spot deploy action to link the token to the EVM:

Copy
/**
 * @param token - The token index to link
 * @param address - The address of the ERC20 contract on the evm.
 * @param evmExtraWeiDecimals - The difference in Wei decimals between Core and EVM spot. E.g. Core PURR has 5 weiDecimals but EVM PURR has 18, so this would be 13. evmExtraWeiDecimals should be in the range [-2, 18] inclusive
 */
interface RequestEvmContract {
  type: ‚ÄúrequestEvmContract‚Äù;
  token: number;
  Address: address;
  evmExtraWeiDecimals: number;
}
After sending this action, HyperCore will store the pending EVM address to be linked. The deployer of the EVM contract must then verify their intention to link to the HyperCore token in one of two ways:

If the EVM contract was deployed from an EOA, the EVM user can send an action using the nonce that was used to deploy the EVM contract.

If the EVM contract was deployed by another contract (e.g. create2 via a multisig), the contract's first storage slot must store the HyperCore deployer's address. This can be done at initialization by defining the first state variable in solidity. 

To finalize the link, a finalizer sends the following action (note that this not nested in a spot deploy action). In the "create" case, the EVM deployer sends the action, and in the "firstStorageSlot" case, the Core token deployer sends the action.

Copy
/**
 * @param input - One of the two EVM deployer options above
 */
interface FinalizeEvmContract {
  type: ‚ÄúfinalizeEvmContract‚Äù;
  token: number;
  input: {"create": {"nonce": number}} | "firstStorageSlot"};
}
Caveats
There are currently no checks that the system address has sufficient supply or that the contract is a valid ERC20, so be careful when sending funds.

In particular, the linked contract may have arbitrary bytecode, so it's prudent to verify that its implementation is correct. There are no guarantees about what the transfer call does on the EVM, so make sure to verify the source code and total balance of the linked EVM contract. 

If the EVM contract has extra Wei decimals, then if the relevant log emitted has a value that is not round (does not end in extraEvmWeiDecimals zeros), the non-round amount is burned (guaranteed to be <1 Wei). This is true for both HYPE and any other spot tokens.

Mainnet PURR
Mainnet PURR is deployed as an ERC20 contract at 0x9b498C3c8A0b8CD8BA1D9851d40D186F1872b44E with the following code. It will be linked to PURR on HyperCore once linking is enabled on mainnet.

Copy
// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";

contract Purr is ERC20Permit {
    constructor() ERC20("Purr", "PURR") ERC20Permit("Purr") {
        address initialHolder = 0x2000000000000000000000000000000000000001;
        uint256 initialBalance = 600000000;

        _mint(initialHolder, initialBalance * 10 ** decimals());
    }
}
Final Notes
Attached is a sample script for deploying an ERC20 token to the EVM and linking it to a Core spot token.





For developers
HyperEVM
Wrapped HYPE
A canonical system contract for wrapped HYPE is deployed at 0x555...5. The contract is immutable, with the same source code as wrapped ETH on Ethereum, apart from the token name and symbol. 

The source code for WHYPE is provided below. Note that this is based on the WETH contract on Ethereum mainnet and other EVM chains.

Copy
pragma solidity >=0.4.22 <0.6;

contract WHYPE9 {
  string public name = "Wrapped HYPE";
  string public symbol = "WHYPE";
  uint8 public decimals = 18;

  event Approval(address indexed src, address indexed guy, uint wad);
  event Transfer(address indexed src, address indexed dst, uint wad);
  event Deposit(address indexed dst, uint wad);
  event Withdrawal(address indexed src, uint wad);

  mapping(address => uint) public balanceOf;
  mapping(address => mapping(address => uint)) public allowance;

  function() external payable {
    deposit();
  }

  function deposit() public payable {
    balanceOf[msg.sender] += msg.value;
    emit Deposit(msg.sender, msg.value);
  }

  function withdraw(uint wad) public {
    require(balanceOf[msg.sender] >= wad);
    balanceOf[msg.sender] -= wad;
    msg.sender.transfer(wad);
    emit Withdrawal(msg.sender, wad);
  }

  function totalSupply() public view returns (uint) {
    return address(this).balance;
  }

  function approve(address guy, uint wad) public returns (bool) {
    allowance[msg.sender][guy] = wad;
    emit Approval(msg.sender, guy, wad);
    return true;
  }

  function transfer(address dst, uint wad) public returns (bool) {
    return transferFrom(msg.sender, dst, wad);
  }

  function transferFrom(address src, address dst, uint wad) public returns (bool) {
    require(balanceOf[src] >= wad);

    if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
      require(allowance[src][msg.sender] >= wad);
      allowance[src][msg.sender] -= wad;
    }

    balanceOf[src] -= wad;
    balanceOf[dst] += wad;

    emit Transfer(src, dst, wad);

    return true;
  }
}




For developers
HyperEVM
JSON-RPC
The following RPC endpoints are available

net_version

web3_clientVersion

eth_blockNumber

eth_call

only the latest block is supported

eth_chainId

eth_estimateGas

only the latest block is supported

eth_feeHistory

eth_gasPrice

returns the base fee for the next small block

eth_getBalance

only the latest block is supported

eth_getBlockByHash

eth_getBlockByNumber

eth_getBlockReceipts

eth_getBlockTransactionCountByHash

eth_getBlockTransactionCountByNumber

eth_getCode

only the latest block is supported

eth_getLogs

up to 4 topics

up to 50 blocks in query range

eth_getStorageAt

only the latest block is supported

eth_getTransactionByBlockHashAndIndex

eth_getTransactionByBlockNumberAndIndex

eth_getTransactionByHash

eth_getTransactionCount

only the latest block is supported

eth_getTransactionReceipt

eth_maxPriorityFeePerGas

always returns zero currently

eth_syncing

always returns false

The following custom endpoints are available

eth_bigBlockGasPrice

returns the base fee for the next big block

eth_usingBigBlocks

returns whether the address is using big blocks

eth_getSystemTxsByBlockHash  and eth_getSystemTxsByBlockNumber

similar to the "getTransaction" analogs but returns the system transactions that originate from HyperCore

Unsupported requests

Requests that require historical state are not supported at this time on the default RPC implementation. However, independent archive node implementations are available for use, and the GitHub repository has examples on how to get started indexing historical data locally. Note that read precompiles are only recorded for the calls actually made on each block. Hypothetical read precompile results could be obtained from a full L1 replay.


For developers
Nodes
Documentation for running nodes

You can run a node by following the non-validator and validator nodes by following the steps in https://github.com/hyperliquid-dex/node.





For developers
Nodes
L1 Data Schemas
The node writes data to ~/hl/data. With default settings, the network will generate around 100 GB of logs per day, so it is recommended to archive or delete old files.

The command line flags to generate the auxiliary data below can be found at https://github.com/hyperliquid-dex/node 

Transaction Blocks
Blocks parsed as transactions are streamed to

Copy
~/hl/data/replica_cmds/{start_time}/{date}/{height}
State Snapshots

State snapshots are saved every 10,000 blocks to

Copy
~/hl/data/periodic_abci_states/{date}/{height}.rmp
Trades
Trades data is saved to 

Copy
~/hl/data/node_trades/hourly/{date}/{hour}
Copy
// Example trade
{
  "coin": "COMP",
  "side": "B",
  "time": "2024-07-26T08:26:25.899",
  "px": "51.367",
  "sz": "0.31",
  "hash": "0xad8e0566e813bdf98176040e6d51bd011100efa789e89430cdf17964235f55d8",
  "trade_dir_override":"Na",
  // side_info always has length 2
  // side_info[0] is the buyer
  // side_info[1] is the seller
  "side_info": [
    {
      "user": "0xc64cc00b46101bd40aa1c3121195e85c0b0918d8",
      "start_pos": "996.67",
      "oid": 12212201265,
      "twap_id": null,
      "cloid": null
    },
    {
      "user": "0x768484f7e2ebb675c57838366c02ae99ba2a9b08",
      "start_pos": "-996.7",
      "oid": 12212198275,
      "twap_id": null,
      "cloid": null
    }
  ]
}
Order Statuses
Order status data is saved to

Copy
~/hl/data/node_order_statuses/hourly/{date}/{hour}
Copy
// Example order status
{
  "time": "2024-07-26T08:31:48.717",
  "user": "0xc64cc00b46101bd40aa1c3121195e85c0b0918d8",
  "status": "canceled",
  "order": {
    "coin": "INJ",
    "side": "A",
    "limitPx": "25.381",
    // filled size
    "sz": "257.0",
    "oid": 12212359592,
    "timestamp": 1721982700270,
    "triggerCondition": "N/A",
    "isTrigger": false,
    "triggerPx": "0.0",
    "children": [],
    "isPositionTpsl": false,
    "reduceOnly": false,
    "orderType": "Limit",
    // original order size
    "origSz": "257.0",
    "tif": "Alo",
    "cloid": null
  }
}
Miscellaneous Events
Miscellaneous event data is saved to

Copy
~/hl/data/misc_events/hourly/{date}/{hour}
Miscellaneous events currently include the following

Staking deposits

Staking delegations

Staking withdrawals

Validator rewards

Ledger updates (funding distributions, spot transfers, etc)

Copy
type MiscEvent = {
  time: string;
  hash: string;
  inner: MiscEventInner;
}

type MiscEventInner = CDeposit | Delegation | CWithdrawal | ValidatorRewards | Funding | LedgerUpdate;

type CDeposit = {
  user: string;
  amount: number;
}

type Delegation = {
  user: string;
  validator: string;
  amount: number;
  is_undelegate: boolean;
}

type CWithdrawal = {
  user: string;
  amount: number;
  is_finalized: boolean;
}

type ValidatorRewards = {
  validator_to_reward: Array<[string, number]>;
}

type Funding {
  coin: string;
  usdc: number;
  szi: number;
  fundingRate: number;
  nSamples: number;
}

type LedgerUpdate = {
  users: Array<string>;
  delta: LedgerDelta;
}

// InternalTransfer means Perp USDC transfer
// RewardsClaim is for builder and referrer fees
// Deposit/Withdraw refer to Arbitrum USDC bridge
type LedgerDelta = Withdraw 
  | Deposit
  | VaultCreate
  | VaultDeposit
  | VaultWithdraw
  | VaultDistribution
  | VaultLeaderCommission
  | Liquidation
  | InternalTransfer
  | SubAccountTransfer
  | SpotTransfer
  | SpotGenesis
  | RewardsClaim
  | AccountActivationGas
  | PerpDexClassTransfer
  | DeployGasAuction;
  
type Withdraw = {
  usdc: number;
  nonce: number;
  fee: number;
}

type Deposit = {
  usdc: number;
}

type VaultCreate {
  vault: string;
  usdc: number;
  fee: number;
}

type VaultWithdraw {
  vault: string;
  user: string;
  requestedUsd: number;
  commission: number;
  closingCost: number;
  basis: number;
}

type VaultDistribution {
  vault: string;
  usdc: number;
}

type Liquidation {
  liquidatedNtlPos: number;
  accountValue: number;
  leverageType: string;
  liquidatedPositions: Array<LiquidatedPosition>;
}

type LiquidatedPosition {
  coin: string;
  szi: number;
}
 
type InternalTransfer {
  usdc: number;
  user: string;
  destination: string;
  fee: number;
}

type AccountClassTransfer {
  usdc: number;
  toPerp: boolean;
}

type SubAccountTransfer {
  usdc: number;
  user: string;
  destination: string;
}

type SpotTransfer {
  token: string;
  amount: number;
  usdcValue: number;
  user: string;
  destination: string;
  fee: number;
  nativeTokenFee: number;
}

type SpotGenesis {
  token: string;
  amount: number;
}

type RewardsClaim {
  amount: number;
}

type AccountActivationGas {
  amount: number;
  token: string;
}

type PerpDexClassTransfer {
  amount: number;
  token: string;
  dex: string;
  toPerp: boolean;
}

type DeployGasAuction {
  token: string;
  amount: number;
}
L4 Snapshots
Given an abci state, the node can compute an L4 book snapshot, which is the entire order book with full information about the orders for each level. This can be used as a checkpoint upon which the order statuses stream may be applied, allowing users to stream an L4 book in realtime. 

Orders in the snapshot are sorted in time-order at the same price level. Trigger orders come at the end and be differentiated with isTrigger .

Copy
[
  [
    "BTC", // coin
    [
      [ // bids
        {
          "coin": "BTC",
          "side": "B",
          "limitPx": "103988.0",
          "sz": "0.2782",
          "oid": 30112287571,
          "timestamp": 1747157301016,
          "triggerCondition": "N/A",
          "isTrigger": false,
          "triggerPx": "0.0",
          "children": [],
          "isPositionTpsl": false,
          "reduceOnly": false,
          "orderType": "Limit",
          "origSz": "0.2782",
          "tif": "Alo",
          "cloid": null
        },
        ..
      ],
      [ // asks
        {
          "coin": "BTC",
          "side": "A",
          "limitPx": "93708.0",
          "sz": "0.00047",
          "oid": 30073539988,
          "timestamp": 1747128626867,
          "triggerCondition": "Price below 101856",
          "isTrigger": true,
          "triggerPx": "101856.0",
          "children": [],
          "isPositionTpsl": false,
          "reduceOnly": true,
          "orderType": "Stop Market",
          "origSz": "0.00047",
          "tif": null,
          "cloid": null
        },
        ..
      ]
    ]
  ],
  [
    "ETH",
    ..
  ],
  [
    "SOL",
    ..
  ]
]







------------------------------------------------------------------------


HYPER LIQUID SDK ALL PASTED INTO ONE CODE BELOW FOR REFERENCE AND USE IF NEEDED 


SDK FOR HYPER LIQUID 


import json
import logging
import secrets

import eth_account
from eth_account.signers.local import LocalAccount

from hyperliquid.api import API
from hyperliquid.info import Info
from hyperliquid.utils.constants import MAINNET_API_URL
from hyperliquid.utils.signing import (
    CancelByCloidRequest,
    CancelRequest,
    ModifyRequest,
    OidOrCloid,
    OrderRequest,
    OrderType,
    OrderWire,
    ScheduleCancelAction,
    float_to_usd_int,
    get_timestamp_ms,
    order_request_to_order_wire,
    order_wires_to_order_action,
    sign_agent,
    sign_approve_builder_fee,
    sign_convert_to_multi_sig_user_action,
    sign_l1_action,
    sign_multi_sig_action,
    sign_spot_transfer_action,
    sign_usd_class_transfer_action,
    sign_usd_transfer_action,
    sign_withdraw_from_bridge_action,
)
from hyperliquid.utils.types import Any, BuilderInfo, Cloid, List, Meta, Optional, SpotMeta, Tuple


class Exchange(API):
    # Default Max Slippage for Market Orders 5%
    DEFAULT_SLIPPAGE = 0.05

    def __init__(
        self,
        wallet: LocalAccount,
        base_url: Optional[str] = None,
        meta: Optional[Meta] = None,
        vault_address: Optional[str] = None,
        account_address: Optional[str] = None,
        spot_meta: Optional[SpotMeta] = None,
    ):
        super().__init__(base_url)
        self.wallet = wallet
        self.vault_address = vault_address
        self.account_address = account_address
        self.info = Info(base_url, True, meta, spot_meta)

    def _post_action(self, action, signature, nonce):
        payload = {
            "action": action,
            "nonce": nonce,
            "signature": signature,
            "vaultAddress": self.vault_address if action["type"] != "usdClassTransfer" else None,
        }
        logging.debug(payload)
        return self.post("/exchange", payload)

    def _slippage_price(
        self,
        name: str,
        is_buy: bool,
        slippage: float,
        px: Optional[float] = None,
    ) -> float:
        coin = self.info.name_to_coin[name]
        if not px:
            # Get midprice
            px = float(self.info.all_mids()[coin])

        # spot assets start at 10000
        is_spot = self.info.coin_to_asset[coin] >= 10_000

        # Calculate Slippage
        px *= (1 + slippage) if is_buy else (1 - slippage)
        # We round px to 5 significant figures and 6 decimals for perps, 8 decimals for spot
        return round(float(f"{px:.5g}"), 6 if not is_spot else 8)

    def order(
        self,
        name: str,
        is_buy: bool,
        sz: float,
        limit_px: float,
        order_type: OrderType,
        reduce_only: bool = False,
        cloid: Optional[Cloid] = None,
        builder: Optional[BuilderInfo] = None,
    ) -> Any:
        order: OrderRequest = {
            "coin": name,
            "is_buy": is_buy,
            "sz": sz,
            "limit_px": limit_px,
            "order_type": order_type,
            "reduce_only": reduce_only,
        }
        if cloid:
            order["cloid"] = cloid
        return self.bulk_orders([order], builder)

    def bulk_orders(self, order_requests: List[OrderRequest], builder: Optional[BuilderInfo] = None) -> Any:
        order_wires: List[OrderWire] = [
            order_request_to_order_wire(order, self.info.name_to_asset(order["coin"])) for order in order_requests
        ]
        timestamp = get_timestamp_ms()

        if builder:
            builder["b"] = builder["b"].lower()
        order_action = order_wires_to_order_action(order_wires, builder)

        signature = sign_l1_action(
            self.wallet,
            order_action,
            self.vault_address,
            timestamp,
            self.base_url == MAINNET_API_URL,
        )

        return self._post_action(
            order_action,
            signature,
            timestamp,
        )

    def modify_order(
        self,
        oid: OidOrCloid,
        name: str,
        is_buy: bool,
        sz: float,
        limit_px: float,
        order_type: OrderType,
        reduce_only: bool = False,
        cloid: Optional[Cloid] = None,
    ) -> Any:
        modify: ModifyRequest = {
            "oid": oid,
            "order": {
                "coin": name,
                "is_buy": is_buy,
                "sz": sz,
                "limit_px": limit_px,
                "order_type": order_type,
                "reduce_only": reduce_only,
                "cloid": cloid,
            },
        }
        return self.bulk_modify_orders_new([modify])

    def bulk_modify_orders_new(self, modify_requests: List[ModifyRequest]) -> Any:
        timestamp = get_timestamp_ms()
        modify_wires = [
            {
                "oid": modify["oid"].to_raw() if isinstance(modify["oid"], Cloid) else modify["oid"],
                "order": order_request_to_order_wire(modify["order"], self.info.name_to_asset(modify["order"]["coin"])),
            }
            for modify in modify_requests
        ]

        modify_action = {
            "type": "batchModify",
            "modifies": modify_wires,
        }

        signature = sign_l1_action(
            self.wallet,
            modify_action,
            self.vault_address,
            timestamp,
            self.base_url == MAINNET_API_URL,
        )

        return self._post_action(
            modify_action,
            signature,
            timestamp,
        )

    def market_open(
        self,
        name: str,
        is_buy: bool,
        sz: float,
        px: Optional[float] = None,
        slippage: float = DEFAULT_SLIPPAGE,
        cloid: Optional[Cloid] = None,
        builder: Optional[BuilderInfo] = None,
    ) -> Any:
        # Get aggressive Market Price
        px = self._slippage_price(name, is_buy, slippage, px)
        # Market Order is an aggressive Limit Order IoC
        return self.order(
            name, is_buy, sz, px, order_type={"limit": {"tif": "Ioc"}}, reduce_only=False, cloid=cloid, builder=builder
        )

    def market_close(
        self,
        coin: str,
        sz: Optional[float] = None,
        px: Optional[float] = None,
        slippage: float = DEFAULT_SLIPPAGE,
        cloid: Optional[Cloid] = None,
        builder: Optional[BuilderInfo] = None,
    ) -> Any:
        address = self.wallet.address
        if self.account_address:
            address = self.account_address
        if self.vault_address:
            address = self.vault_address
        positions = self.info.user_state(address)["assetPositions"]
        for position in positions:
            item = position["position"]
            if coin != item["coin"]:
                continue
            szi = float(item["szi"])
            if not sz:
                sz = abs(szi)
            is_buy = True if szi < 0 else False
            # Get aggressive Market Price
            px = self._slippage_price(coin, is_buy, slippage, px)
            # Market Order is an aggressive Limit Order IoC
            return self.order(
                coin,
                is_buy,
                sz,
                px,
                order_type={"limit": {"tif": "Ioc"}},
                reduce_only=True,
                cloid=cloid,
                builder=builder,
            )

    def cancel(self, name: str, oid: int) -> Any:
        return self.bulk_cancel([{"coin": name, "oid": oid}])

    def cancel_by_cloid(self, name: str, cloid: Cloid) -> Any:
        return self.bulk_cancel_by_cloid([{"coin": name, "cloid": cloid}])

    def bulk_cancel(self, cancel_requests: List[CancelRequest]) -> Any:
        timestamp = get_timestamp_ms()
        cancel_action = {
            "type": "cancel",
            "cancels": [
                {
                    "a": self.info.name_to_asset(cancel["coin"]),
                    "o": cancel["oid"],
                }
                for cancel in cancel_requests
            ],
        }
        signature = sign_l1_action(
            self.wallet,
            cancel_action,
            self.vault_address,
            timestamp,
            self.base_url == MAINNET_API_URL,
        )

        return self._post_action(
            cancel_action,
            signature,
            timestamp,
        )

    def bulk_cancel_by_cloid(self, cancel_requests: List[CancelByCloidRequest]) -> Any:
        timestamp = get_timestamp_ms()

        cancel_action = {
            "type": "cancelByCloid",
            "cancels": [
                {
                    "asset": self.info.name_to_asset(cancel["coin"]),
                    "cloid": cancel["cloid"].to_raw(),
                }
                for cancel in cancel_requests
            ],
        }
        signature = sign_l1_action(
            self.wallet,
            cancel_action,
            self.vault_address,
            timestamp,
            self.base_url == MAINNET_API_URL,
        )

        return self._post_action(
            cancel_action,
            signature,
            timestamp,
        )

    def schedule_cancel(self, time: Optional[int]) -> Any:
        """Schedules a time (in UTC millis) to cancel all open orders. The time must be at least 5 seconds after the current time.
        Once the time comes, all open orders will be canceled and a trigger count will be incremented. The max number of triggers
        per day is 10. This trigger count is reset at 00:00 UTC.

        Args:
            time (int): if time is not None, then set the cancel time in the future. If None, then unsets any cancel time in the future.
        """
        timestamp = get_timestamp_ms()
        schedule_cancel_action: ScheduleCancelAction = {
            "type": "scheduleCancel",
        }
        if time is not None:
            schedule_cancel_action["time"] = time
        signature = sign_l1_action(
            self.wallet,
            schedule_cancel_action,
            self.vault_address,
            timestamp,
            self.base_url == MAINNET_API_URL,
        )
        return self._post_action(
            schedule_cancel_action,
            signature,
            timestamp,
        )

    def update_leverage(self, leverage: int, name: str, is_cross: bool = True) -> Any:
        timestamp = get_timestamp_ms()
        update_leverage_action = {
            "type": "updateLeverage",
            "asset": self.info.name_to_asset(name),
            "isCross": is_cross,
            "leverage": leverage,
        }
        signature = sign_l1_action(
            self.wallet,
            update_leverage_action,
            self.vault_address,
            timestamp,
            self.base_url == MAINNET_API_URL,
        )
        return self._post_action(
            update_leverage_action,
            signature,
            timestamp,
        )

    def update_isolated_margin(self, amount: float, name: str) -> Any:
        timestamp = get_timestamp_ms()
        amount = float_to_usd_int(amount)
        update_isolated_margin_action = {
            "type": "updateIsolatedMargin",
            "asset": self.info.name_to_asset(name),
            "isBuy": True,
            "ntli": amount,
        }
        signature = sign_l1_action(
            self.wallet,
            update_isolated_margin_action,
            self.vault_address,
            timestamp,
            self.base_url == MAINNET_API_URL,
        )
        return self._post_action(
            update_isolated_margin_action,
            signature,
            timestamp,
        )

    def set_referrer(self, code: str) -> Any:
        timestamp = get_timestamp_ms()
        set_referrer_action = {
            "type": "setReferrer",
            "code": code,
        }
        signature = sign_l1_action(
            self.wallet,
            set_referrer_action,
            None,
            timestamp,
            self.base_url == MAINNET_API_URL,
        )
        return self._post_action(
            set_referrer_action,
            signature,
            timestamp,
        )

    def create_sub_account(self, name: str) -> Any:
        timestamp = get_timestamp_ms()
        create_sub_account_action = {
            "type": "createSubAccount",
            "name": name,
        }
        signature = sign_l1_action(
            self.wallet,
            create_sub_account_action,
            None,
            timestamp,
            self.base_url == MAINNET_API_URL,
        )
        return self._post_action(
            create_sub_account_action,
            signature,
            timestamp,
        )

    def usd_class_transfer(self, amount: float, to_perp: bool) -> Any:
        timestamp = get_timestamp_ms()
        str_amount = str(amount)
        if self.vault_address:
            str_amount += f" subaccount:{self.vault_address}"

        action = {
            "type": "usdClassTransfer",
            "amount": str_amount,
            "toPerp": to_perp,
            "nonce": timestamp,
        }
        signature = sign_usd_class_transfer_action(self.wallet, action, self.base_url == MAINNET_API_URL)
        return self._post_action(
            action,
            signature,
            timestamp,
        )

    def sub_account_transfer(self, sub_account_user: str, is_deposit: bool, usd: int) -> Any:
        timestamp = get_timestamp_ms()
        sub_account_transfer_action = {
            "type": "subAccountTransfer",
            "subAccountUser": sub_account_user,
            "isDeposit": is_deposit,
            "usd": usd,
        }
        signature = sign_l1_action(
            self.wallet,
            sub_account_transfer_action,
            None,
            timestamp,
            self.base_url == MAINNET_API_URL,
        )
        return self._post_action(
            sub_account_transfer_action,
            signature,
            timestamp,
        )

    def vault_usd_transfer(self, vault_address: str, is_deposit: bool, usd: int) -> Any:
        timestamp = get_timestamp_ms()
        vault_transfer_action = {
            "type": "vaultTransfer",
            "vaultAddress": vault_address,
            "isDeposit": is_deposit,
            "usd": usd,
        }
        is_mainnet = self.base_url == MAINNET_API_URL
        signature = sign_l1_action(self.wallet, vault_transfer_action, None, timestamp, is_mainnet)
        return self._post_action(
            vault_transfer_action,
            signature,
            timestamp,
        )

    def usd_transfer(self, amount: float, destination: str) -> Any:
        timestamp = get_timestamp_ms()
        action = {"destination": destination, "amount": str(amount), "time": timestamp, "type": "usdSend"}
        is_mainnet = self.base_url == MAINNET_API_URL
        signature = sign_usd_transfer_action(self.wallet, action, is_mainnet)
        return self._post_action(
            action,
            signature,
            timestamp,
        )

    def spot_transfer(self, amount: float, destination: str, token: str) -> Any:
        timestamp = get_timestamp_ms()
        action = {
            "destination": destination,
            "amount": str(amount),
            "token": token,
            "time": timestamp,
            "type": "spotSend",
        }
        is_mainnet = self.base_url == MAINNET_API_URL
        signature = sign_spot_transfer_action(self.wallet, action, is_mainnet)
        return self._post_action(
            action,
            signature,
            timestamp,
        )

    def withdraw_from_bridge(self, amount: float, destination: str) -> Any:
        timestamp = get_timestamp_ms()
        action = {"destination": destination, "amount": str(amount), "time": timestamp, "type": "withdraw3"}
        is_mainnet = self.base_url == MAINNET_API_URL
        signature = sign_withdraw_from_bridge_action(self.wallet, action, is_mainnet)
        return self._post_action(
            action,
            signature,
            timestamp,
        )

    def approve_agent(self, name: Optional[str] = None) -> Tuple[Any, str]:
        agent_key = "0x" + secrets.token_hex(32)
        account = eth_account.Account.from_key(agent_key)
        timestamp = get_timestamp_ms()
        is_mainnet = self.base_url == MAINNET_API_URL
        action = {
            "type": "approveAgent",
            "agentAddress": account.address,
            "agentName": name or "",
            "nonce": timestamp,
        }
        signature = sign_agent(self.wallet, action, is_mainnet)
        if name is None:
            del action["agentName"]

        return (
            self._post_action(
                action,
                signature,
                timestamp,
            ),
            agent_key,
        )

    def approve_builder_fee(self, builder: str, max_fee_rate: str) -> Any:
        timestamp = get_timestamp_ms()

        action = {"maxFeeRate": max_fee_rate, "builder": builder, "nonce": timestamp, "type": "approveBuilderFee"}
        signature = sign_approve_builder_fee(self.wallet, action, self.base_url == MAINNET_API_URL)
        return self._post_action(action, signature, timestamp)

    def convert_to_multi_sig_user(self, authorized_users: List[str], threshold: int) -> Any:
        timestamp = get_timestamp_ms()
        authorized_users = sorted(authorized_users)
        signers = {
            "authorizedUsers": authorized_users,
            "threshold": threshold,
        }
        action = {
            "type": "convertToMultiSigUser",
            "signers": json.dumps(signers),
            "nonce": timestamp,
        }
        signature = sign_convert_to_multi_sig_user_action(self.wallet, action, self.base_url == MAINNET_API_URL)
        return self._post_action(
            action,
            signature,
            timestamp,
        )

    def multi_sig(self, multi_sig_user, inner_action, signatures, nonce, vault_address=None):
        multi_sig_user = multi_sig_user.lower()
        multi_sig_action = {
            "type": "multiSig",
            "signatureChainId": "0x66eee",
            "signatures": signatures,
            "payload": {
                "multiSigUser": multi_sig_user,
                "outerSigner": self.wallet.address.lower(),
                "action": inner_action,
            },
        }
        is_mainnet = self.base_url == MAINNET_API_URL
        signature = sign_multi_sig_action(
            self.wallet,
            multi_sig_action,
            is_mainnet,
            vault_address,
            nonce,
        )
        return self._post_action(
            multi_sig_action,
            signature,
            nonce,
        )


from hyperliquid.api import API
from hyperliquid.utils.types import (
    Any,
    Callable,
    Cloid,
    Meta,
    Optional,
    SpotMeta,
    SpotMetaAndAssetCtxs,
    Subscription,
    cast,
)
from hyperliquid.websocket_manager import WebsocketManager


class Info(API):
    def __init__(
        self,
        base_url: Optional[str] = None,
        skip_ws: Optional[bool] = False,
        meta: Optional[Meta] = None,
        spot_meta: Optional[SpotMeta] = None,
    ):
        super().__init__(base_url)
        if not skip_ws:
            self.ws_manager = WebsocketManager(self.base_url)
            self.ws_manager.start()
        else:
            self.ws_manager = None
        if meta is None:
            meta = self.meta()

        if spot_meta is None:
            spot_meta = self.spot_meta()

        self.coin_to_asset = {asset_info["name"]: asset for (asset, asset_info) in enumerate(meta["universe"])}
        self.name_to_coin = {asset_info["name"]: asset_info["name"] for asset_info in meta["universe"]}

        # spot assets start at 10000
        for spot_info in spot_meta["universe"]:
            self.coin_to_asset[spot_info["name"]] = spot_info["index"] + 10000
            self.name_to_coin[spot_info["name"]] = spot_info["name"]
            base, quote = spot_info["tokens"]
            name = f'{spot_meta["tokens"][base]["name"]}/{spot_meta["tokens"][quote]["name"]}'
            if name not in self.name_to_coin:
                self.name_to_coin[name] = spot_info["name"]

    def disconnect_websocket(self):
        if self.ws_manager is None:
            raise RuntimeError("Cannot call disconnect_websocket since skip_ws was used")
        else:
            self.ws_manager.stop()

    def user_state(self, address: str) -> Any:
        """Retrieve trading details about a user.

        POST /info

        Args:
            address (str): Onchain address in 42-character hexadecimal format;
                            e.g. 0x0000000000000000000000000000000000000000.
        Returns:
            {
                assetPositions: [
                    {
                        position: {
                            coin: str,
                            entryPx: Optional[float string]
                            leverage: {
                                type: "cross" | "isolated",
                                value: int,
                                rawUsd: float string  # only if type is "isolated"
                            },
                            liquidationPx: Optional[float string]
                            marginUsed: float string,
                            positionValue: float string,
                            returnOnEquity: float string,
                            szi: float string,
                            unrealizedPnl: float string
                        },
                        type: "oneWay"
                    }
                ],
                crossMarginSummary: MarginSummary,
                marginSummary: MarginSummary,
                withdrawable: float string,
            }

            where MarginSummary is {
                    accountValue: float string,
                    totalMarginUsed: float string,
                    totalNtlPos: float string,
                    totalRawUsd: float string,
                }
        """
        return self.post("/info", {"type": "clearinghouseState", "user": address})

    def spot_user_state(self, address: str) -> Any:
        return self.post("/info", {"type": "spotClearinghouseState", "user": address})

    def open_orders(self, address: str) -> Any:
        """Retrieve a user's open orders.

        POST /info

        Args:
            address (str): Onchain address in 42-character hexadecimal format;
                            e.g. 0x0000000000000000000000000000000000000000.
        Returns: [
            {
                coin: str,
                limitPx: float string,
                oid: int,
                side: "A" | "B",
                sz: float string,
                timestamp: int
            }
        ]
        """
        return self.post("/info", {"type": "openOrders", "user": address})

    def frontend_open_orders(self, address: str) -> Any:
        """Retrieve a user's open orders with additional frontend info.

        POST /info

        Args:
            address (str): Onchain address in 42-character hexadecimal format;
                            e.g. 0x0000000000000000000000000000000000000000.
        Returns: [
            {
                children:
                    [
                        dict of frontend orders
                    ]
                coin: str,
                isPositionTpsl: bool,
                isTrigger: bool,
                limitPx: float string,
                oid: int,
                orderType: str,
                origSz: float string,
                reduceOnly: bool,
                side: "A" | "B",
                sz: float string,
                tif: str,
                timestamp: int,
                triggerCondition: str,
                triggerPx: float str
            }
        ]
        """
        return self.post("/info", {"type": "frontendOpenOrders", "user": address})

    def all_mids(self) -> Any:
        """Retrieve all mids for all actively traded coins.

        POST /info

        Returns:
            {
              ATOM: float string,
              BTC: float string,
              any other coins which are trading: float string
            }
        """
        return self.post("/info", {"type": "allMids"})

    def user_fills(self, address: str) -> Any:
        """Retrieve a given user's fills.

        POST /info

        Args:
            address (str): Onchain address in 42-character hexadecimal format;
                            e.g. 0x0000000000000000000000000000000000000000.

        Returns:
            [
              {
                closedPnl: float string,
                coin: str,
                crossed: bool,
                dir: str,
                hash: str,
                oid: int,
                px: float string,
                side: str,
                startPosition: float string,
                sz: float string,
                time: int
              },
              ...
            ]
        """
        return self.post("/info", {"type": "userFills", "user": address})

    def user_fills_by_time(self, address: str, start_time: int, end_time: Optional[int] = None) -> Any:
        """Retrieve a given user's fills by time.

        POST /info

        Args:
            address (str): Onchain address in 42-character hexadecimal format;
                            e.g. 0x0000000000000000000000000000000000000000.
            start_time (int): Unix timestamp in milliseconds
            end_time (Optional[int]): Unix timestamp in milliseconds

        Returns:
            [
              {
                closedPnl: float string,
                coin: str,
                crossed: bool,
                dir: str,
                hash: str,
                oid: int,
                px: float string,
                side: str,
                startPosition: float string,
                sz: float string,
                time: int
              },
              ...
            ]
        """
        return self.post(
            "/info", {"type": "userFillsByTime", "user": address, "startTime": start_time, "endTime": end_time}
        )

    def meta(self) -> Meta:
        """Retrieve exchange perp metadata

        POST /info

        Returns:
            {
                universe: [
                    {
                        name: str,
                        szDecimals: int
                    },
                    ...
                ]
            }
        """
        return cast(Meta, self.post("/info", {"type": "meta"}))

    def meta_and_asset_ctxs(self) -> Any:
        """Retrieve exchange MetaAndAssetCtxs

        POST /info

        Returns:
            [
                {
                    universe: [
                        {
                            'name': str,
                            'szDecimals': int
                            'maxLeverage': int,
                            'onlyIsolated': bool,
                        },
                        ...
                    ]
                },
            [
                {
                    "dayNtlVlm": float string,
                    "funding": float string,
                    "impactPxs": Optional([float string, float string]),
                    "markPx": Optional(float string),
                    "midPx": Optional(float string),
                    "openInterest": float string,
                    "oraclePx": float string,
                    "premium": Optional(float string),
                    "prevDayPx": float string
                },
                ...
            ]
        """
        return self.post("/info", {"type": "metaAndAssetCtxs"})

    def spot_meta(self) -> SpotMeta:
        """Retrieve exchange spot metadata

        POST /info

        Returns:
            {
                universe: [
                    {
                        tokens: [int, int],
                        name: str,
                        index: int,
                        isCanonical: bool
                    },
                    ...
                ],
                tokens: [
                    {
                        name: str,
                        szDecimals: int,
                        weiDecimals: int,
                        index: int,
                        tokenId: str,
                        isCanonical: bool
                    },
                    ...
                ]
            }
        """
        return cast(SpotMeta, self.post("/info", {"type": "spotMeta"}))

    def spot_meta_and_asset_ctxs(self) -> SpotMetaAndAssetCtxs:
        """Retrieve exchange spot asset contexts
        POST /info
        Returns:
            [
                {
                    universe: [
                        {
                            tokens: [int, int],
                            name: str,
                            index: int,
                            isCanonical: bool
                        },
                        ...
                    ],
                    tokens: [
                        {
                            name: str,
                            szDecimals: int,
                            weiDecimals: int,
                            index: int,
                            tokenId: str,
                            isCanonical: bool
                        },
                        ...
                    ]
                },
                [
                    {
                        dayNtlVlm: float string,
                        markPx: float string,
                        midPx: Optional(float string),
                        prevDayPx: float string,
                        circulatingSupply: float string,
                        coin: str
                    }
                    ...
                ]
            ]
        """
        return cast(SpotMetaAndAssetCtxs, self.post("/info", {"type": "spotMetaAndAssetCtxs"}))

    def funding_history(self, name: str, startTime: int, endTime: Optional[int] = None) -> Any:
        """Retrieve funding history for a given coin

        POST /info

        Args:
            name (str): Coin to retrieve funding history for.
            startTime (int): Unix timestamp in milliseconds.
            endTime (int): Unix timestamp in milliseconds.

        Returns:
            [
                {
                    coin: str,
                    fundingRate: float string,
                    premium: float string,
                    time: int
                },
                ...
            ]
        """
        coin = self.name_to_coin[name]
        if endTime is not None:
            return self.post(
                "/info", {"type": "fundingHistory", "coin": coin, "startTime": startTime, "endTime": endTime}
            )
        return self.post("/info", {"type": "fundingHistory", "coin": coin, "startTime": startTime})

    def user_funding_history(self, user: str, startTime: int, endTime: Optional[int] = None) -> Any:
        """Retrieve a user's funding history
        POST /info
        Args:
            user (str): Address of the user in 42-character hexadecimal format.
            startTime (int): Start time in milliseconds, inclusive.
            endTime (int, optional): End time in milliseconds, inclusive. Defaults to current time.
        Returns:
            List[Dict]: A list of funding history records, where each record contains:
                - user (str): User address.
                - type (str): Type of the record, e.g., "userFunding".
                - startTime (int): Unix timestamp of the start time in milliseconds.
                - endTime (int): Unix timestamp of the end time in milliseconds.
        """
        if endTime is not None:
            return self.post("/info", {"type": "userFunding", "user": user, "startTime": startTime, "endTime": endTime})
        return self.post("/info", {"type": "userFunding", "user": user, "startTime": startTime})

    def l2_snapshot(self, name: str) -> Any:
        """Retrieve L2 snapshot for a given coin

        POST /info

        Args:
            name (str): Coin to retrieve L2 snapshot for.

        Returns:
            {
                coin: str,
                levels: [
                    [
                        {
                            n: int,
                            px: float string,
                            sz: float string
                        },
                        ...
                    ],
                    ...
                ],
                time: int
            }
        """
        return self.post("/info", {"type": "l2Book", "coin": self.name_to_coin[name]})

    def candles_snapshot(self, name: str, interval: str, startTime: int, endTime: int) -> Any:
        """Retrieve candles snapshot for a given coin

        POST /info

        Args:
            name (str): Coin to retrieve candles snapshot for.
            interval (str): Candlestick interval.
            startTime (int): Unix timestamp in milliseconds.
            endTime (int): Unix timestamp in milliseconds.

        Returns:
            [
                {
                    T: int,
                    c: float string,
                    h: float string,
                    i: str,
                    l: float string,
                    n: int,
                    o: float string,
                    s: string,
                    t: int,
                    v: float string
                },
                ...
            ]
        """
        req = {"coin": self.name_to_coin[name], "interval": interval, "startTime": startTime, "endTime": endTime}
        return self.post("/info", {"type": "candleSnapshot", "req": req})

    def user_fees(self, address: str) -> Any:
        """Retrieve the volume of trading activity associated with a user.
        POST /info
        Args:
            address (str): Onchain address in 42-character hexadecimal format;
                            e.g. 0x0000000000000000000000000000000000000000.
        Returns:
            {
                activeReferralDiscount: float string,
                dailyUserVlm: [
                    {
                        date: str,
                        exchange: str,
                        userAdd: float string,
                        userCross: float string
                    },
                ],
                feeSchedule: {
                    add: float string,
                    cross: float string,
                    referralDiscount: float string,
                    tiers: {
                        mm: [
                            {
                                add: float string,
                                makerFractionCutoff: float string
                            },
                        ],
                        vip: [
                            {
                                add: float string,
                                cross: float string,
                                ntlCutoff: float string
                            },
                        ]
                    }
                },
                userAddRate: float string,
                userCrossRate: float string
            }
        """
        return self.post("/info", {"type": "userFees", "user": address})
    
    def user_staking_summary(self, address: str) -> Any:
        """Retrieve the staking summary associated with a user.
        POST /info
        Args:
            address (str): Onchain address in 42-character hexadecimal format;
                            e.g. 0x0000000000000000000000000000000000000000.
        Returns:
            {
                delegated: float string,
                undelegated: float string,
                totalPendingWithdrawal: float string,
                nPendingWithdrawals: int
            }
        """
        return self.post("/info", {"type": "delegatorSummary", "user": address})
    
    def user_staking_delegations(self, address: str) -> Any:
        """Retrieve the user's staking delegations.
        POST /info
        Args:
            address (str): Onchain address in 42-character hexadecimal format;
                            e.g. 0x0000000000000000000000000000000000000000.
        Returns:
            [
                {
                    validator: string,
                    amount: float string,
                    lockedUntilTimestamp: int
                },
            ]
        """
        return self.post("/info", {"type": "delegations", "user": address})
    
    def user_staking_rewards(self, address: str) -> Any:
        """Retrieve the historic staking rewards associated with a user.
        POST /info
        Args:
            address (str): Onchain address in 42-character hexadecimal format;
                            e.g. 0x0000000000000000000000000000000000000000.
        Returns:
            [
                {
                    time: int,
                    source: string,
                    totalAmount: float string
                },
            ]
        """
        return self.post("/info", {"type": "delegatorRewards", "user": address})

    def query_order_by_oid(self, user: str, oid: int) -> Any:
        return self.post("/info", {"type": "orderStatus", "user": user, "oid": oid})

    def query_order_by_cloid(self, user: str, cloid: Cloid) -> Any:
        return self.post("/info", {"type": "orderStatus", "user": user, "oid": cloid.to_raw()})

    def query_referral_state(self, user: str) -> Any:
        return self.post("/info", {"type": "referral", "user": user})

    def query_sub_accounts(self, user: str) -> Any:
        return self.post("/info", {"type": "subAccounts", "user": user})

    def query_user_to_multi_sig_signers(self, multi_sig_user: str) -> Any:
        return self.post("/info", {"type": "userToMultiSigSigners", "user": multi_sig_user})

    def subscribe(self, subscription: Subscription, callback: Callable[[Any], None]) -> int:
        if subscription["type"] == "l2Book" or subscription["type"] == "trades" or subscription["type"] == "candle":
            subscription["coin"] = self.name_to_coin[subscription["coin"]]
        if self.ws_manager is None:
            raise RuntimeError("Cannot call subscribe since skip_ws was used")
        else:
            return self.ws_manager.subscribe(subscription, callback)

    def unsubscribe(self, subscription: Subscription, subscription_id: int) -> bool:
        if subscription["type"] == "l2Book" or subscription["type"] == "trades" or subscription["type"] == "candle":
            subscription["coin"] = self.name_to_coin[subscription["coin"]]
        if self.ws_manager is None:
            raise RuntimeError("Cannot call unsubscribe since skip_ws was used")
        else:
            return self.ws_manager.unsubscribe(subscription, subscription_id)

    def name_to_asset(self, name: str) -> int:
        return self.coin_to_asset[self.name_to_coin[name]]



import json
import logging
import threading
import time
from collections import defaultdict

import websocket

from hyperliquid.utils.types import Any, Callable, Dict, List, NamedTuple, Optional, Subscription, Tuple, WsMsg

ActiveSubscription = NamedTuple("ActiveSubscription", [("callback", Callable[[Any], None]), ("subscription_id", int)])


def subscription_to_identifier(subscription: Subscription) -> str:
    if subscription["type"] == "allMids":
        return "allMids"
    elif subscription["type"] == "l2Book":
        return f'l2Book:{subscription["coin"].lower()}'
    elif subscription["type"] == "trades":
        return f'trades:{subscription["coin"].lower()}'
    elif subscription["type"] == "userEvents":
        return "userEvents"
    elif subscription["type"] == "userFills":
        return f'userFills:{subscription["user"].lower()}'
    elif subscription["type"] == "candle":
        return f'candle:{subscription["coin"].lower()},{subscription["interval"]}'
    elif subscription["type"] == "orderUpdates":
        return "orderUpdates"
    elif subscription["type"] == "userFundings":
        return f'userFundings:{subscription["user"].lower()}'
    elif subscription["type"] == "userNonFundingLedgerUpdates":
        return f'userNonFundingLedgerUpdates:{subscription["user"].lower()}'
    elif subscription["type"] == "webData2":
        return f'webData2:{subscription["user"].lower()}'


def ws_msg_to_identifier(ws_msg: WsMsg) -> Optional[str]:
    if ws_msg["channel"] == "pong":
        return "pong"
    elif ws_msg["channel"] == "allMids":
        return "allMids"
    elif ws_msg["channel"] == "l2Book":
        return f'l2Book:{ws_msg["data"]["coin"].lower()}'
    elif ws_msg["channel"] == "trades":
        trades = ws_msg["data"]
        if len(trades) == 0:
            return None
        else:
            return f'trades:{trades[0]["coin"].lower()}'
    elif ws_msg["channel"] == "user":
        return "userEvents"
    elif ws_msg["channel"] == "userFills":
        return f'userFills:{ws_msg["data"]["user"].lower()}'
    elif ws_msg["channel"] == "candle":
        return f'candle:{ws_msg["data"]["s"].lower()},{ws_msg["data"]["i"]}'
    elif ws_msg["channel"] == "orderUpdates":
        return "orderUpdates"
    elif ws_msg["channel"] == "userFundings":
        return f'userFundings:{ws_msg["data"]["user"].lower()}'
    elif ws_msg["channel"] == "userNonFundingLedgerUpdates":
        return f'userNonFundingLedgerUpdates:{ws_msg["data"]["user"].lower()}'
    elif ws_msg["channel"] == "webData2":
        return f'webData2:{ws_msg["data"]["user"].lower()}'


class WebsocketManager(threading.Thread):
    def __init__(self, base_url):
        super().__init__()
        self.subscription_id_counter = 0
        self.ws_ready = False
        self.queued_subscriptions: List[Tuple[Subscription, ActiveSubscription]] = []
        self.active_subscriptions: Dict[str, List[ActiveSubscription]] = defaultdict(list)
        ws_url = "ws" + base_url[len("http") :] + "/ws"
        self.ws = websocket.WebSocketApp(ws_url, on_message=self.on_message, on_open=self.on_open)
        self.ping_sender = threading.Thread(target=self.send_ping)
        self.stop_event = threading.Event()

    def run(self):
        self.ws.run_forever()
        self.ping_sender.start()

    def send_ping(self):
        while not self.stop_event.wait(50):
            if not self.ws.keep_running:
                break
            logging.debug("Websocket sending ping")
            self.ws.send(json.dumps({"method": "ping"}))
        logging.debug("Websocket ping sender stopped")

    def stop(self):
        self.stop_event.set()
        self.ws.close()
        if self.ping_sender.is_alive():
            self.ping_sender.join()

    def on_message(self, _ws, message):
        if message == "Websocket connection established.":
            logging.debug(message)
            return
        logging.debug(f"on_message {message}")
        ws_msg: WsMsg = json.loads(message)
        identifier = ws_msg_to_identifier(ws_msg)
        if identifier == "pong":
            logging.debug("Websocket received pong")
            return
        if identifier is None:
            logging.debug("Websocket not handling empty message")
            return
        active_subscriptions = self.active_subscriptions[identifier]
        if len(active_subscriptions) == 0:
            print("Websocket message from an unexpected subscription:", message, identifier)
        else:
            for active_subscription in active_subscriptions:
                active_subscription.callback(ws_msg)

    def on_open(self, _ws):
        logging.debug("on_open")
        self.ws_ready = True
        for subscription, active_subscription in self.queued_subscriptions:
            self.subscribe(subscription, active_subscription.callback, active_subscription.subscription_id)

    def subscribe(
        self, subscription: Subscription, callback: Callable[[Any], None], subscription_id: Optional[int] = None
    ) -> int:
        if subscription_id is None:
            self.subscription_id_counter += 1
            subscription_id = self.subscription_id_counter
        if not self.ws_ready:
            logging.debug("enqueueing subscription")
            self.queued_subscriptions.append((subscription, ActiveSubscription(callback, subscription_id)))
        else:
            logging.debug("subscribing")
            identifier = subscription_to_identifier(subscription)
            if identifier == "userEvents" or identifier == "orderUpdates":
                # TODO: ideally the userEvent and orderUpdates messages would include the user so that we can multiplex
                if len(self.active_subscriptions[identifier]) != 0:
                    raise NotImplementedError(f"Cannot subscribe to {identifier} multiple times")
            self.active_subscriptions[identifier].append(ActiveSubscription(callback, subscription_id))
            self.ws.send(json.dumps({"method": "subscribe", "subscription": subscription}))
        return subscription_id

    def unsubscribe(self, subscription: Subscription, subscription_id: int) -> bool:
        if not self.ws_ready:
            raise NotImplementedError("Can't unsubscribe before websocket connected")
        identifier = subscription_to_identifier(subscription)
        active_subscriptions = self.active_subscriptions[identifier]
        new_active_subscriptions = [x for x in active_subscriptions if x.subscription_id != subscription_id]
        if len(new_active_subscriptions) == 0:
            self.ws.send(json.dumps({"method": "unsubscribe", "subscription": subscription}))
        self.active_subscriptions[identifier] = new_active_subscriptions
        return len(active_subscriptions) != len(new_active_subscriptions)




import json
import logging
from json import JSONDecodeError

import requests

from hyperliquid.utils.constants import MAINNET_API_URL
from hyperliquid.utils.error import ClientError, ServerError
from hyperliquid.utils.types import Any


class API:
    def __init__(self, base_url=None):
        self.base_url = base_url or MAINNET_API_URL
        self.session = requests.Session()
        self.session.headers.update({"Content-Type": "application/json"})
        self._logger = logging.getLogger(__name__)

    def post(self, url_path: str, payload: Any = None) -> Any:
        payload = payload or {}
        url = self.base_url + url_path
        response = self.session.post(url, json=payload)
        self._handle_exception(response)
        try:
            return response.json()
        except ValueError:
            return {"error": f"Could not parse JSON: {response.text}"}

    def _handle_exception(self, response):
        status_code = response.status_code
        if status_code < 400:
            return
        if 400 <= status_code < 500:
            try:
                err = json.loads(response.text)
            except JSONDecodeError:
                raise ClientError(status_code, None, response.text, None, response.headers)
            if err is None:
                raise ClientError(status_code, None, response.text, None, response.headers)
            error_data = err.get("data")
            raise ClientError(status_code, err["code"], err["msg"], response.headers, error_data)
        raise ServerError(status_code, response.text)


MAINNET_API_URL = "https://api.hyperliquid.xyz"
TESTNET_API_URL = "https://api.hyperliquid-testnet.xyz"
LOCAL_API_URL = "http://localhost:3001"



class Error(Exception):
    pass


class ClientError(Error):
    def __init__(self, status_code, error_code, error_message, header, error_data=None):
        self.status_code = status_code
        self.error_code = error_code
        self.error_message = error_message
        self.header = header
        self.error_data = error_data


class ServerError(Error):
    def __init__(self, status_code, message):
        self.status_code = status_code
        self.message = message





import time
from decimal import Decimal

import msgpack
from eth_account.messages import encode_typed_data
from eth_utils import keccak, to_hex

from hyperliquid.utils.types import Cloid, Literal, NotRequired, Optional, TypedDict, Union

Tif = Union[Literal["Alo"], Literal["Ioc"], Literal["Gtc"]]
Tpsl = Union[Literal["tp"], Literal["sl"]]
LimitOrderType = TypedDict("LimitOrderType", {"tif": Tif})
TriggerOrderType = TypedDict("TriggerOrderType", {"triggerPx": float, "isMarket": bool, "tpsl": Tpsl})
TriggerOrderTypeWire = TypedDict("TriggerOrderTypeWire", {"triggerPx": str, "isMarket": bool, "tpsl": Tpsl})
OrderType = TypedDict("OrderType", {"limit": LimitOrderType, "trigger": TriggerOrderType}, total=False)
OrderTypeWire = TypedDict("OrderTypeWire", {"limit": LimitOrderType, "trigger": TriggerOrderTypeWire}, total=False)
OrderRequest = TypedDict(
    "OrderRequest",
    {
        "coin": str,
        "is_buy": bool,
        "sz": float,
        "limit_px": float,
        "order_type": OrderType,
        "reduce_only": bool,
        "cloid": NotRequired[Optional[Cloid]],
    },
    total=False,
)
OidOrCloid = Union[int, Cloid]
ModifyRequest = TypedDict(
    "ModifyRequest",
    {
        "oid": OidOrCloid,
        "order": OrderRequest,
    },
    total=False,
)
CancelRequest = TypedDict("CancelRequest", {"coin": str, "oid": int})
CancelByCloidRequest = TypedDict("CancelByCloidRequest", {"coin": str, "cloid": Cloid})

Grouping = Union[Literal["na"], Literal["normalTpsl"], Literal["positionTpsl"]]
Order = TypedDict(
    "Order", {"asset": int, "isBuy": bool, "limitPx": float, "sz": float, "reduceOnly": bool, "cloid": Optional[Cloid]}
)


OrderWire = TypedDict(
    "OrderWire",
    {
        "a": int,
        "b": bool,
        "p": str,
        "s": str,
        "r": bool,
        "t": OrderTypeWire,
        "c": NotRequired[Optional[str]],
    },
)

ModifyWire = TypedDict(
    "ModifyWire",
    {
        "oid": int,
        "order": OrderWire,
    },
)

ScheduleCancelAction = TypedDict(
    "ScheduleCancelAction",
    {
        "type": Literal["scheduleCancel"],
        "time": NotRequired[Optional[int]],
    },
)

USD_SEND_SIGN_TYPES = [
    {"name": "hyperliquidChain", "type": "string"},
    {"name": "destination", "type": "string"},
    {"name": "amount", "type": "string"},
    {"name": "time", "type": "uint64"},
]

SPOT_TRANSFER_SIGN_TYPES = [
    {"name": "hyperliquidChain", "type": "string"},
    {"name": "destination", "type": "string"},
    {"name": "token", "type": "string"},
    {"name": "amount", "type": "string"},
    {"name": "time", "type": "uint64"},
]

WITHDRAW_SIGN_TYPES = [
    {"name": "hyperliquidChain", "type": "string"},
    {"name": "destination", "type": "string"},
    {"name": "amount", "type": "string"},
    {"name": "time", "type": "uint64"},
]

USD_CLASS_TRANSFER_SIGN_TYPES = [
    {"name": "hyperliquidChain", "type": "string"},
    {"name": "amount", "type": "string"},
    {"name": "toPerp", "type": "bool"},
    {"name": "nonce", "type": "uint64"},
]

CONVERT_TO_MULTI_SIG_USER_SIGN_TYPES = [
    {"name": "hyperliquidChain", "type": "string"},
    {"name": "signers", "type": "string"},
    {"name": "nonce", "type": "uint64"},
]

MULTI_SIG_ENVELOPE_SIGN_TYPES = [
    {"name": "hyperliquidChain", "type": "string"},
    {"name": "multiSigActionHash", "type": "bytes32"},
    {"name": "nonce", "type": "uint64"},
]


def order_type_to_wire(order_type: OrderType) -> OrderTypeWire:
    if "limit" in order_type:
        return {"limit": order_type["limit"]}
    elif "trigger" in order_type:
        return {
            "trigger": {
                "isMarket": order_type["trigger"]["isMarket"],
                "triggerPx": float_to_wire(order_type["trigger"]["triggerPx"]),
                "tpsl": order_type["trigger"]["tpsl"],
            }
        }
    raise ValueError("Invalid order type", order_type)


def address_to_bytes(address):
    return bytes.fromhex(address[2:] if address.startswith("0x") else address)


def action_hash(action, vault_address, nonce):
    data = msgpack.packb(action)
    data += nonce.to_bytes(8, "big")
    if vault_address is None:
        data += b"\x00"
    else:
        data += b"\x01"
        data += address_to_bytes(vault_address)
    return keccak(data)


def construct_phantom_agent(hash, is_mainnet):
    return {"source": "a" if is_mainnet else "b", "connectionId": hash}


def sign_l1_action(wallet, action, active_pool, nonce, is_mainnet):
    hash = action_hash(action, active_pool, nonce)
    phantom_agent = construct_phantom_agent(hash, is_mainnet)
    data = {
        "domain": {
            "chainId": 1337,
            "name": "Exchange",
            "verifyingContract": "0x0000000000000000000000000000000000000000",
            "version": "1",
        },
        "types": {
            "Agent": [
                {"name": "source", "type": "string"},
                {"name": "connectionId", "type": "bytes32"},
            ],
            "EIP712Domain": [
                {"name": "name", "type": "string"},
                {"name": "version", "type": "string"},
                {"name": "chainId", "type": "uint256"},
                {"name": "verifyingContract", "type": "address"},
            ],
        },
        "primaryType": "Agent",
        "message": phantom_agent,
    }
    return sign_inner(wallet, data)


def sign_user_signed_action(wallet, action, payload_types, primary_type, is_mainnet):
    action["signatureChainId"] = "0x66eee"
    action["hyperliquidChain"] = "Mainnet" if is_mainnet else "Testnet"
    data = {
        "domain": {
            "name": "HyperliquidSignTransaction",
            "version": "1",
            "chainId": 421614,
            "verifyingContract": "0x0000000000000000000000000000000000000000",
        },
        "types": {
            primary_type: payload_types,
            "EIP712Domain": [
                {"name": "name", "type": "string"},
                {"name": "version", "type": "string"},
                {"name": "chainId", "type": "uint256"},
                {"name": "verifyingContract", "type": "address"},
            ],
        },
        "primaryType": primary_type,
        "message": action,
    }
    return sign_inner(wallet, data)


def add_multi_sig_types(sign_types):
    enriched_sign_types = []
    enriched = False
    for sign_type in sign_types:
        enriched_sign_types.append(sign_type)
        if sign_type["name"] == "hyperliquidChain":
            enriched = True
            enriched_sign_types.append(
                {
                    "name": "payloadMultiSigUser",
                    "type": "address",
                }
            )
            enriched_sign_types.append(
                {
                    "name": "outerSigner",
                    "type": "address",
                }
            )
    if not enriched:
        print('"hyperliquidChain" missing from sign_types. sign_types was not enriched with multi-sig signing types')
    return enriched_sign_types


def add_multi_sig_fields(action, payload_multi_sig_user, outer_signer):
    action = action.copy()
    action["payloadMultiSigUser"] = payload_multi_sig_user.lower()
    action["outerSigner"] = outer_signer.lower()
    return action


def sign_multi_sig_user_signed_action_payload(
    wallet, action, is_mainnet, sign_types, tx_type, payload_multi_sig_user, outer_signer
):
    envelope = add_multi_sig_fields(action, payload_multi_sig_user, outer_signer)
    sign_types = add_multi_sig_types(sign_types)
    return sign_user_signed_action(
        wallet,
        envelope,
        sign_types,
        tx_type,
        is_mainnet,
    )


def sign_multi_sig_l1_action_payload(
    wallet, action, is_mainnet, vault_address, timestamp, payload_multi_sig_user, outer_signer
):
    envelope = [payload_multi_sig_user.lower(), outer_signer.lower(), action]
    return sign_l1_action(
        wallet,
        envelope,
        vault_address,
        timestamp,
        is_mainnet,
    )


def sign_multi_sig_action(wallet, action, is_mainnet, vault_address, nonce):
    action_without_tag = action.copy()
    del action_without_tag["type"]
    multi_sig_action_hash = action_hash(action_without_tag, vault_address, nonce)
    envelope = {
        "multiSigActionHash": multi_sig_action_hash,
        "nonce": nonce,
    }
    return sign_user_signed_action(
        wallet,
        envelope,
        MULTI_SIG_ENVELOPE_SIGN_TYPES,
        "HyperliquidTransaction:SendMultiSig",
        is_mainnet,
    )


def sign_usd_transfer_action(wallet, action, is_mainnet):
    return sign_user_signed_action(
        wallet,
        action,
        USD_SEND_SIGN_TYPES,
        "HyperliquidTransaction:UsdSend",
        is_mainnet,
    )


def sign_spot_transfer_action(wallet, action, is_mainnet):
    return sign_user_signed_action(
        wallet,
        action,
        SPOT_TRANSFER_SIGN_TYPES,
        "HyperliquidTransaction:SpotSend",
        is_mainnet,
    )


def sign_withdraw_from_bridge_action(wallet, action, is_mainnet):
    return sign_user_signed_action(
        wallet,
        action,
        WITHDRAW_SIGN_TYPES,
        "HyperliquidTransaction:Withdraw",
        is_mainnet,
    )


def sign_usd_class_transfer_action(wallet, action, is_mainnet):
    return sign_user_signed_action(
        wallet,
        action,
        USD_CLASS_TRANSFER_SIGN_TYPES,
        "HyperliquidTransaction:UsdClassTransfer",
        is_mainnet,
    )


def sign_convert_to_multi_sig_user_action(wallet, action, is_mainnet):
    return sign_user_signed_action(
        wallet,
        action,
        CONVERT_TO_MULTI_SIG_USER_SIGN_TYPES,
        "HyperliquidTransaction:ConvertToMultiSigUser",
        is_mainnet,
    )


def sign_agent(wallet, action, is_mainnet):
    return sign_user_signed_action(
        wallet,
        action,
        [
            {"name": "hyperliquidChain", "type": "string"},
            {"name": "agentAddress", "type": "address"},
            {"name": "agentName", "type": "string"},
            {"name": "nonce", "type": "uint64"},
        ],
        "HyperliquidTransaction:ApproveAgent",
        is_mainnet,
    )


def sign_approve_builder_fee(wallet, action, is_mainnet):
    return sign_user_signed_action(
        wallet,
        action,
        [
            {"name": "hyperliquidChain", "type": "string"},
            {"name": "maxFeeRate", "type": "string"},
            {"name": "builder", "type": "address"},
            {"name": "nonce", "type": "uint64"},
        ],
        "HyperliquidTransaction:ApproveBuilderFee",
        is_mainnet,
    )


def sign_inner(wallet, data):
    structured_data = encode_typed_data(full_message=data)
    signed = wallet.sign_message(structured_data)
    return {"r": to_hex(signed["r"]), "s": to_hex(signed["s"]), "v": signed["v"]}


def float_to_wire(x: float) -> str:
    rounded = "{:.8f}".format(x)
    if abs(float(rounded) - x) >= 1e-12:
        raise ValueError("float_to_wire causes rounding", x)
    if rounded == "-0":
        rounded = "0"
    normalized = Decimal(rounded).normalize()
    return f"{normalized:f}"


def float_to_int_for_hashing(x: float) -> int:
    return float_to_int(x, 8)


def float_to_usd_int(x: float) -> int:
    return float_to_int(x, 6)


def float_to_int(x: float, power: int) -> int:
    with_decimals = x * 10**power
    if abs(round(with_decimals) - with_decimals) >= 1e-3:
        raise ValueError("float_to_int causes rounding", x)
    res: int = round(with_decimals)
    return res


def get_timestamp_ms() -> int:
    return int(time.time() * 1000)


def order_request_to_order_wire(order: OrderRequest, asset: int) -> OrderWire:
    order_wire: OrderWire = {
        "a": asset,
        "b": order["is_buy"],
        "p": float_to_wire(order["limit_px"]),
        "s": float_to_wire(order["sz"]),
        "r": order["reduce_only"],
        "t": order_type_to_wire(order["order_type"]),
    }
    if "cloid" in order and order["cloid"] is not None:
        order_wire["c"] = order["cloid"].to_raw()
    return order_wire


def order_wires_to_order_action(order_wires, builder=None):
    action = {
        "type": "order",
        "orders": order_wires,
        "grouping": "na",
    }
    if builder:
        action["builder"] = builder
    return action





from __future__ import annotations

from typing import Any, Callable, Dict, List, Literal, NamedTuple, Optional, Tuple, TypedDict, Union, cast
from typing_extensions import NotRequired

Any = Any
Option = Optional
cast = cast
Callable = Callable
NamedTuple = NamedTuple
NotRequired = NotRequired

AssetInfo = TypedDict("AssetInfo", {"name": str, "szDecimals": int})
Meta = TypedDict("Meta", {"universe": List[AssetInfo]})
Side = Union[Literal["A"], Literal["B"]]
SIDES: List[Side] = ["A", "B"]

SpotAssetInfo = TypedDict("SpotAssetInfo", {"name": str, "tokens": List[int], "index": int, "isCanonical": bool})
SpotTokenInfo = TypedDict(
    "SpotTokenInfo",
    {
        "name": str,
        "szDecimals": int,
        "weiDecimals": int,
        "index": int,
        "tokenId": str,
        "isCanonical": bool,
        "evmContract": Optional[str],
        "fullName": Optional[str],
    },
)
SpotMeta = TypedDict("SpotMeta", {"universe": List[SpotAssetInfo], "tokens": List[SpotTokenInfo]})
SpotAssetCtx = TypedDict(
    "SpotAssetCtx",
    {"dayNtlVlm": str, "markPx": str, "midPx": Optional[str], "prevDayPx": str, "circulatingSupply": str, "coin": str},
)
SpotMetaAndAssetCtxs = Tuple[SpotMeta, List[SpotAssetCtx]]

AllMidsSubscription = TypedDict("AllMidsSubscription", {"type": Literal["allMids"]})
L2BookSubscription = TypedDict("L2BookSubscription", {"type": Literal["l2Book"], "coin": str})
TradesSubscription = TypedDict("TradesSubscription", {"type": Literal["trades"], "coin": str})
UserEventsSubscription = TypedDict("UserEventsSubscription", {"type": Literal["userEvents"], "user": str})
UserFillsSubscription = TypedDict("UserFillsSubscription", {"type": Literal["userFills"], "user": str})
CandleSubscription = TypedDict("CandleSubscription", {"type": Literal["candle"], "coin": str, "interval": str})
OrderUpdatesSubscription = TypedDict("OrderUpdatesSubscription", {"type": Literal["orderUpdates"], "user": str})
UserFundingsSubscription = TypedDict("UserFundingsSubscription", {"type": Literal["userFundings"], "user": str})
UserNonFundingLedgerUpdatesSubscription = TypedDict(
    "UserNonFundingLedgerUpdatesSubscription", {"type": Literal["userNonFundingLedgerUpdates"], "user": str}
)
WebData2Subscription = TypedDict("WebData2Subscription", {"type": Literal["webData2"], "user": str})
# If adding new subscription types that contain coin's don't forget to handle automatically rewrite name to coin in info.subscribe
Subscription = Union[
    AllMidsSubscription,
    L2BookSubscription,
    TradesSubscription,
    UserEventsSubscription,
    UserFillsSubscription,
    CandleSubscription,
    OrderUpdatesSubscription,
    UserFundingsSubscription,
    UserNonFundingLedgerUpdatesSubscription,
    WebData2Subscription,
]

AllMidsData = TypedDict("AllMidsData", {"mids": Dict[str, str]})
AllMidsMsg = TypedDict("AllMidsMsg", {"channel": Literal["allMids"], "data": AllMidsData})
L2Level = TypedDict("L2Level", {"px": str, "sz": str, "n": int})
L2BookData = TypedDict("L2BookData", {"coin": str, "levels": Tuple[List[L2Level]], "time": int})
L2BookMsg = TypedDict("L2BookMsg", {"channel": Literal["l2Book"], "data": L2BookData})
PongMsg = TypedDict("PongMsg", {"channel": Literal["pong"]})
Trade = TypedDict("Trade", {"coin": str, "side": Side, "px": str, "sz": int, "hash": str, "time": int})
TradesMsg = TypedDict("TradesMsg", {"channel": Literal["trades"], "data": List[Trade]})
Fill = TypedDict(
    "Fill",
    {
        "coin": str,
        "px": str,
        "sz": str,
        "side": Side,
        "time": int,
        "startPosition": str,
        "dir": str,
        "closedPnl": str,
        "hash": str,
        "oid": int,
        "crossed": bool,
        "fee": str,
        "tid": int,
        "feeToken": str,
    },
)
# TODO: handle other types of user events
UserEventsData = TypedDict("UserEventsData", {"fills": List[Fill]}, total=False)
UserEventsMsg = TypedDict("UserEventsMsg", {"channel": Literal["user"], "data": UserEventsData})
UserFillsData = TypedDict("UserFillsData", {"user": str, "isSnapshot": bool, "fills": List[Fill]})
UserFillsMsg = TypedDict("UserFillsMsg", {"channel": Literal["userFills"], "data": UserFillsData})
OtherWsMsg = TypedDict(
    "OtherWsMsg",
    {
        "channel": Union[
            Literal["candle"],
            Literal["orderUpdates"],
            Literal["userFundings"],
            Literal["userNonFundingLedgerUpdates"],
            Literal["webData2"],
        ],
        "data": Any,
    },
    total=False,
)
WsMsg = Union[AllMidsMsg, L2BookMsg, TradesMsg, UserEventsMsg, PongMsg, UserFillsMsg, OtherWsMsg]

# b is the public address of the builder, f is the amount of the fee in tenths of basis points. e.g. 10 means 1 basis point
BuilderInfo = TypedDict("BuilderInfo", {"b": str, "f": int})


class Cloid:
    def __init__(self, raw_cloid: str):
        self._raw_cloid: str = raw_cloid
        self._validate()

    def _validate(self):
        assert self._raw_cloid[:2] == "0x", "cloid is not a hex string"
        assert len(self._raw_cloid[2:]) == 32, "cloid is not 16 bytes"

    def __str__(self):
        return str(self._raw_cloid)

    def __repr__(self):
        return str(self._raw_cloid)
    
    @staticmethod
    def from_int(cloid: int) -> Cloid:
        return Cloid(f"{cloid:#034x}")

    @staticmethod
    def from_str(cloid: str) -> Cloid:
        return Cloid(cloid)

    def to_raw(self):
        return self._raw_cloid





























